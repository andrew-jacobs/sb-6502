
Portable 65xx Assembler [16.06]

                             ;===============================================================================
                             ;  ____  ____         __  ____   ____ ___ ____                 
                             ; / ___|| __ )       / /_| ___| / ___/ _ \___ \                
                             ; \___ \|  _ \ _____| '_ \___ \| |  | | | |__) |               
                             ;  ___) | |_) |_____| (_) |__) | |__| |_| / __/                
                             ; |____/|____/       \___/____/_\____\___/_____|_              
                             ; | __ )  ___   ___ | |_  |  \/  | ___  _ __ (_) |_ ___  _ __  
                             ; |  _ \ / _ \ / _ \| __| | |\/| |/ _ \| '_ \| | __/ _ \| '__| 
                             ; | |_) | (_) | (_) | |_  | |  | | (_) | | | | | || (_) | |    
                             ; |____/ \___/ \___/ \__| |_|  |_|\___/|_| |_|_|\__\___/|_|    
                             ;
                             ;
                             ;-------------------------------------------------------------------------------
                             ; Copyright (C)2014-2016 Andrew John Jacobs.
                             ; All rights reserved.
                             ;
                             ; This work is made available under the terms of the Creative Commons
                             ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
                             ; following URL to see the details.
                             ;
                             ; http://creativecommons.org/licenses/by-nc-sa/4.0/
                             ;===============================================================================
                             ;
                             ; Notes:
                             ;
                             ;
                             ;-------------------------------------------------------------------------------
                             
                                             .65C02
                                             .include "monitor.asm"
                             
                             ;===============================================================================
                             ; Virtual Peripherals
                             ;-------------------------------------------------------------------------------
                             
         0000FE00          = ACIA_DATA       .EQU    $FE00
         0000FE01          = ACIA_STAT       .EQU    $FE01
         0000FE02          = ACIA_CMND       .EQU    $FE02
         0000FE03          = ACIA_CTRL       .EQU    $FE03
                             
         0000FE04          = SPI_DATA        .EQU    $FE04
         0000FE05          = SPI_STAT        .EQU    $FE05
         0000FE05          = SPI_CTRL        .EQU    $FE05
         0000FE06          = SPI_DVSR        .EQU    $FE06
         0000FE07          = SPI_SLCT        .EQU    $FE07
                             
                             ;===============================================================================
                             ; ASCII Control Characters
                             ;-------------------------------------------------------------------------------
                             
         00000000          = NUL             .EQU    $00
         00000007          = BEL             .EQU    $07
         00000008          = BS              .EQU    $08
         00000009          = HT              .EQU    $09

Portable 65xx Assembler [16.06]

         0000000D          = CR              .EQU    $0D
         0000000A          = LF              .EQU    $0A
         00000011          = DC1             .EQU    $11                     ; XON
         00000013          = DC3             .EQU    $13                     ; XOFF
         0000001B          = ESC             .EQU    $1B
         0000007F          = DEL             .EQU    $7F
                             
                             ;===============================================================================
                             ;-------------------------------------------------------------------------------
                             
         00000000          = OP_ERR          .EQU    $00
         00000002          = OP_ADC          .EQU    $02
         00000004          = OP_AND          .EQU    $04
         00000006          = OP_ASL          .EQU    $06
                                             .IF     __65C02__
         00000008          = OP_BBR          .EQU    $08
         0000000A          = OP_BBS          .EQU    $0A
                                             .ENDIF
         0000000C          = OP_BCC          .EQU    $0C
         0000000E          = OP_BCS          .EQU    $0E
         00000010          = OP_BEQ          .EQU    $10
         00000012          = OP_BIT          .EQU    $12
         00000014          = OP_BNE          .EQU    $14
         00000016          = OP_BMI          .EQU    $16
         00000018          = OP_BPL          .EQU    $18
                                             .IF     __65C02__
         0000001A          = OP_BRA          .EQU    $1A
                                             .ENDIF
         0000001C          = OP_BRK          .EQU    $1C
         0000001E          = OP_BVC          .EQU    $1E
         00000020          = OP_BVS          .EQU    $20
         00000022          = OP_CLC          .EQU    $22
         00000024          = OP_CLD          .EQU    $24
         00000026          = OP_CLI          .EQU    $26
         00000028          = OP_CLV          .EQU    $28
         0000002A          = OP_CMP          .EQU    $2A
         0000002C          = OP_CPX          .EQU    $2C
         0000002E          = OP_CPY          .EQU    $2E
         00000030          = OP_DEC          .EQU    $30
         00000032          = OP_DEX          .EQU    $32
         00000034          = OP_DEY          .EQU    $34
         00000036          = OP_EOR          .EQU    $36
         00000038          = OP_INC          .EQU    $38
         0000003A          = OP_INX          .EQU    $3A
         0000003C          = OP_INY          .EQU    $3C
         0000003E          = OP_JMP          .EQU    $3E
         00000040          = OP_JSR          .EQU    $40
         00000042          = OP_LDA          .EQU    $42
         00000044          = OP_LDX          .EQU    $44
         00000046          = OP_LDY          .EQU    $46
         00000048          = OP_LSR          .EQU    $48
         0000004A          = OP_NOP          .EQU    $4A
         0000004C          = OP_ORA          .EQU    $4C
         0000004E          = OP_PHA          .EQU    $4E

Portable 65xx Assembler [16.06]

         00000050          = OP_PHP          .EQU    $50
                                             .IF     __65C02__
         00000052          = OP_PHX          .EQU    $52
         00000054          = OP_PHY          .EQU    $54
                                             .ENDIF
         00000056          = OP_PLA          .EQU    $56
         00000058          = OP_PLP          .EQU    $58
                                             .IF     __65C02__
         0000005A          = OP_PLX          .EQU    $5A
         0000005C          = OP_PLY          .EQU    $5C
         0000005E          = OP_RMB          .EQU    $5E
                                             .ENDIF
         00000060          = OP_ROL          .EQU    $60
         00000062          = OP_ROR          .EQU    $62
         00000064          = OP_RTI          .EQU    $64
         00000066          = OP_RTS          .EQU    $66
         00000068          = OP_SBC          .EQU    $68
         0000006A          = OP_SEC          .EQU    $6A
         0000006C          = OP_SED          .EQU    $6C
         0000006E          = OP_SEI          .EQU    $6E
                                             .IF     __65C02__
         00000070          = OP_SMB          .EQU    $70
                                             .ENDIF
         00000072          = OP_STA          .EQU    $72
                                             .IF     __65C02__
         00000074          = OP_STP          .EQU    $74
                                             .ENDIF
         00000076          = OP_STX          .EQU    $76
         00000078          = OP_STY          .EQU    $78
                                             .IF     __65C02__
         0000007A          = OP_STZ          .EQU    $7A
                                             .ENDIF
         0000007C          = OP_TAX          .EQU    $7C
         0000007E          = OP_TAY          .EQU    $7E
                                             .IF     __65C02__
         00000080          = OP_TRB          .EQU    $80
         00000082          = OP_TSB          .EQU    $82
                                             .ENDIF
         00000084          = OP_TSX          .EQU    $84
         00000086          = OP_TXA          .EQU    $86
         00000088          = OP_TXS          .EQU    $88
         0000008A          = OP_TYA          .EQU    $8A
                                             .IF     __65C02__
         0000008C          = OP_WAI          .EQU    $8C
                                             .ENDIF
                             
                             ; Bit patterns for addressing modes
                             
         00000080          = MB_IND          .EQU    %10000000
         00000040          = MB_REL          .EQU    %01000000
         00000020          = MB_BIT          .EQU    %00100000
                             
         00000000          = MB_IMP          .EQU    %00000000
         00000001          = MB_ZPG          .EQU    %00000001

Portable 65xx Assembler [16.06]

         00000002          = MB_IMM          .EQU    %00000010
         00000003          = MB_ABS          .EQU    %00000011
                             
         00000010          = MB_ACC          .EQU    %00010000
         00000008          = MB_XRG          .EQU    %00001000
         00000004          = MB_YRG          .EQU    %00000100
                             
                             ; Addressing modes
                             
                                             .IF     __65C02__
         00000021          = MO_BIT          .EQU    MB_BIT       |MB_ZPG
         00000061          = MO_BRL          .EQU    MB_BIT|MB_REL|MB_ZPG
                                             .ENDIF
         00000010          = MO_ACC          .EQU           MB_ACC|MB_IMP
         00000000          = MO_IMP          .EQU                  MB_IMP
         00000002          = MO_IMM          .EQU                  MB_IMM
         00000040          = MO_REL          .EQU                  MB_REL
         00000001          = MO_ZPG          .EQU                  MB_ZPG
         00000005          = MO_ZPX          .EQU           MB_YRG|MB_ZPG
         00000005          = MO_ZPY          .EQU           MB_YRG|MB_ZPG
                                             .IF     __65C02__
         00000081          = MO_IZP          .EQU    MB_IND       |MB_ZPG
                                             .ENDIF
         00000089          = MO_IZX          .EQU    MB_IND|MB_XRG|MB_ZPG
         00000085          = MO_IZY          .EQU    MB_IND|MB_YRG|MB_ZPG
         00000003          = MO_ABS          .EQU                  MB_ABS
         0000000B          = MO_ABX          .EQU           MB_XRG|MB_ABS
         00000007          = MO_ABY          .EQU           MB_YRG|MB_ABS
         00000083          = MO_IAB          .EQU    MB_IND       |MB_ABS
                                             .IF     __65C02__
         0000008B          = MO_IAX          .EQU    MB_IND|MB_XRG|MB_ABS
                                             .ENDIF
                             
                             ;===============================================================================
                             ; Data Areas
                             ;-------------------------------------------------------------------------------
                             
                                             .PAGE0
                                             .ORG    $00F0
                             
00:00F0  00                : A_REG           .SPACE  1
00:00F1  00                : X_REG           .SPACE  1
00:00F2  00                : Y_REG           .SPACE  1
00:00F3  00                : P_REG           .SPACE  1
00:00F4  0000              : PC_REG          .SPACE  2
                             
00:00F6  00                : CMD_LEN         .SPACE  1                       ; Command buffer length
00:00F7  0000              : ADDR_S          .SPACE  2
00:00F9  0000              : ADDR_E          .SPACE  2
                             
00:00FB  0000              : TEMP            .SPACE  2
00:00FD  00                : COUNT           .SPACE  1
                             
                             ;-------------------------------------------------------------------------------

Portable 65xx Assembler [16.06]

                             
                                             .ORG    $00FE
                             
00:00FE  00                : IO_TEMP         .SPACE  1
                             
00:00FF  00                : FLAGS           .SPACE  1               ; I/O Flags for XON/XOFF
                             
         00000080          = FLAG_STOPPED    .EQU    $80
         00000040          = FLAG_STOP       .EQU    $40
                             
                             ;-------------------------------------------------------------------------------
                             
                                             .ORG    $0100
                             
00:0100  0000000000000000> : STACK           .SPACE  256
                             
                             ;===============================================================================
                             ; UART Buffers
                             ;-------------------------------------------------------------------------------
                             
         0000003E          = RX_SIZE         .EQU    62
         0000003E          = TX_SIZE         .EQU    62
                             
         00000080          = CMD_SIZE        .EQU    128
                             
                                             .BSS
                                             .ORG    $0200
                             
                             ; Communications buffer offsets
                             
00:0200  00                : RX_HEAD         .SPACE  1               ; UART recieve buffer offsets
00:0201  00                : RX_TAIL         .SPACE  1
00:0202  00                : TX_HEAD         .SPACE  1               ; UART transmit buffer offsets
00:0203  00                : TX_TAIL         .SPACE  1
                             
00:0204  0000000000000000> : RX_BUFF         .SPACE  RX_SIZE         ; UART recieve buffer
00:0242  0000000000000000> : TX_BUFF         .SPACE  TX_SIZE         ; UART transmit buffer
                             
00:0280  0000000000000000> : BUFFER          .SPACE  CMD_SIZE
                             
                             
                             
                                             .CODE
                                             .ORG    $F000
                             
                             ;===============================================================================
                             ;-------------------------------------------------------------------------------
                             
                                             .IF     __6502__
                           - OPCODES:
                           -                 .BYTE   OP_BRK,OP_ORA,OP_ERR,OP_ERR,OP_ERR,OP_ORA,OP_ASL,OP_ERR ; 0
                           -                 .BYTE   OP_PHP,OP_ORA,OP_ASL,OP_ERR,OP_ERR,OP_ORA,OP_ASL,OP_ERR
                           -                 .BYTE   OP_BPL,OP_ORA,OP_ERR,OP_ERR,OP_ERR,OP_ORA,OP_ASL,OP_ERR ; 1
                           -                 .BYTE   OP_CLC,OP_ORA,OP_INC,OP_ERR,OP_ERR,OP_ORA,OP_ASL,OP_ERR

Portable 65xx Assembler [16.06]

                           -                 .BYTE   OP_JSR,OP_AND,OP_ERR,OP_ERR,OP_BIT,OP_AND,OP_ROL,OP_ERR ; 2
                           -                 .BYTE   OP_PLP,OP_AND,OP_ROL,OP_ERR,OP_BIT,OP_AND,OP_ROL,OP_ERR
                           -                 .BYTE   OP_BMI,OP_AND,OP_ERR,OP_ERR,OP_BIT,OP_AND,OP_ROL,OP_ERR ; 3
                           -                 .BYTE   OP_SEC,OP_AND,OP_DEC,OP_ERR,OP_BIT,OP_AND,OP_ROL,OP_ERR
                           -                 .BYTE   OP_RTI,OP_EOR,OP_ERR,OP_ERR,OP_ERR,OP_EOR,OP_LSR,OP_ERR ; 4
                           -                 .BYTE   OP_PHA,OP_EOR,OP_LSR,OP_ERR,OP_JMP,OP_EOR,OP_LSR,OP_ERR
                           -                 .BYTE   OP_BVC,OP_EOR,OP_ERR,OP_ERR,OP_ERR,OP_EOR,OP_LSR,OP_ERR ; 5
                           -                 .BYTE   OP_CLI,OP_EOR,OP_ERR,OP_ERR,OP_ERR,OP_EOR,OP_LSR,OP_ERR
                           -                 .BYTE   OP_RTS,OP_ADC,OP_ERR,OP_ERR,OP_ERR,OP_ADC,OP_ROR,OP_ERR ; 6
                           -                 .BYTE   OP_PLA,OP_ADC,OP_ROR,OP_ERR,OP_JMP,OP_ADC,OP_ROR,OP_ERR
                           -                 .BYTE   OP_BVS,OP_ADC,OP_ERR,OP_ERR,OP_ERR,OP_ADC,OP_ROR,OP_ERR ; 7
                           -                 .BYTE   OP_SEI,OP_ADC,OP_ERR,OP_ERR,OP_ERR,OP_ADC,OP_ROR,OP_ERR
                           -                 .BYTE   OP_ERR,OP_STA,OP_ERR,OP_ERR,OP_STY,OP_STA,OP_STX,OP_ERR ; 8
                           -                 .BYTE   OP_DEY,OP_BIT,OP_TXA,OP_ERR,OP_STY,OP_STA,OP_STX,OP_ERR
                           -                 .BYTE   OP_BCC,OP_STA,OP_ERR,OP_ERR,OP_STY,OP_STA,OP_STX,OP_ERR ; 9
                           -                 .BYTE   OP_TYA,OP_STA,OP_TXS,OP_ERR,OP_ERR,OP_STA,OP_ERR,OP_ERR
                           -                 .BYTE   OP_LDY,OP_LDA,OP_LDX,OP_ERR,OP_LDY,OP_LDA,OP_LDX,OP_ERR ; A
                           -                 .BYTE   OP_TAY,OP_LDA,OP_TAX,OP_ERR,OP_LDY,OP_LDA,OP_LDX,OP_ERR
                           -                 .BYTE   OP_BCS,OP_LDA,OP_ERR,OP_ERR,OP_LDY,OP_LDA,OP_LDX,OP_ERR ; B
                           -                 .BYTE   OP_CLV,OP_LDA,OP_TSX,OP_ERR,OP_LDY,OP_LDA,OP_LDX,OP_ERR
                           -                 .BYTE   OP_CPY,OP_CMP,OP_ERR,OP_ERR,OP_CPY,OP_CMP,OP_DEC,OP_ERR ; C
                           -                 .BYTE   OP_INY,OP_CMP,OP_DEX,OP_ERR,OP_CPY,OP_CMP,OP_DEC,OP_ERR
                           -                 .BYTE   OP_BNE,OP_CMP,OP_ERR,OP_ERR,OP_ERR,OP_CMP,OP_DEC,OP_ERR ; D
                           -                 .BYTE   OP_CLD,OP_CMP,OP_ERR,OP_ERR,OP_ERR,OP_CMP,OP_DEC,OP_ERR
                           -                 .BYTE   OP_CPX,OP_SBC,OP_ERR,OP_ERR,OP_CPX,OP_SBC,OP_INC,OP_ERR ; E
                           -                 .BYTE   OP_INX,OP_SBC,OP_NOP,OP_ERR,OP_CPX,OP_SBC,OP_INC,OP_ERR
                           -                 .BYTE   OP_BEQ,OP_SBC,OP_ERR,OP_ERR,OP_ERR,OP_SBC,OP_INC,OP_ERR ; F
                           -                 .BYTE   OP_SED,OP_SBC,OP_ERR,OP_ERR,OP_ERR,OP_SBC,OP_INC,OP_ERR
                             
                           - MODES:
                           -                 .BYTE   MO_IMM,MO_IZX,MO_IMM,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_IMP ; 0
                           -                 .BYTE   MO_IMP,MO_IMM,MO_ACC,MO_IMP,MO_IMP,MO_ABS,MO_ABS,MO_IMP
                           -                 .BYTE   MO_REL,MO_IZY,MO_IMP,MO_IMP,MO_IMP,MO_ZPX,MO_ZPX,MO_IMP ; 1
                           -                 .BYTE   MO_IMP,MO_ABY,MO_ACC,MO_IMP,MO_IMP,MO_ABX,MO_ABX,MO_IMP
                           -                 .BYTE   MO_ABS,MO_IZX,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_IMP ; 2
                           -                 .BYTE   MO_IMP,MO_IMM,MO_ACC,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_IMP
                           -                 .BYTE   MO_REL,MO_IZY,MO_IMP,MO_IMP,MO_ZPX,MO_ZPX,MO_ZPX,MO_IMP ; 3
                           -                 .BYTE   MO_IMP,MO_ABY,MO_ACC,MO_IMP,MO_ABX,MO_ABX,MO_ABX,MO_IMP
                           -                 .BYTE   MO_IMP,MO_IZX,MO_IMP,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_IMP ; 4
                           -                 .BYTE   MO_IMP,MO_IMM,MO_ACC,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_IMP
                           -                 .BYTE   MO_REL,MO_IZY,MO_IMP,MO_IMP,MO_IMP,MO_ZPX,MO_ZPX,MO_IMP ; 5
                           -                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_IMP,MO_ABX,MO_ABX,MO_IMP
                           -                 .BYTE   MO_IMP,MO_IZX,MO_IMP,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_IMP ; 6
                           -                 .BYTE   MO_IMP,MO_IMM,MO_ACC,MO_IMP,MO_IAB,MO_ABS,MO_ABS,MO_IMP
                           -                 .BYTE   MO_REL,MO_IZY,MO_IMP,MO_IMP,MO_IMP,MO_ZPX,MO_ZPX,MO_IMP ; 7
                           -                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_IMP,MO_ABX,MO_ABX,MO_IMP
                           -                 .BYTE   MO_IMP,MO_IZX,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_IMP ; 8
                           -                 .BYTE   MO_IMP,MO_IMM,MO_IMP,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_IMP
                           -                 .BYTE   MO_REL,MO_IZY,MO_IMP,MO_IMP,MO_ZPX,MO_ZPX,MO_ZPY,MO_IMP ; 9
                           -                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_IMP,MO_ABX,MO_IMP,MO_IMP
                           -                 .BYTE   MO_IMM,MO_IZX,MO_IMM,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_IMP ; A
                           -                 .BYTE   MO_IMP,MO_IMM,MO_IMP,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_IMP
                           -                 .BYTE   MO_REL,MO_IZY,MO_IMP,MO_IMP,MO_ZPX,MO_ZPX,MO_ZPY,MO_IMP ; B
                           -                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_ABX,MO_ABX,MO_ABY,MO_IMP

Portable 65xx Assembler [16.06]

                           -                 .BYTE   MO_IMM,MO_IZX,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_IMP ; C
                           -                 .BYTE   MO_IMP,MO_IMM,MO_IMP,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_IMP
                           -                 .BYTE   MO_REL,MO_IZY,MO_IMP,MO_IMP,MO_IMP,MO_ZPX,MO_ZPX,MO_IMP ; D
                           -                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_IMP,MO_ABX,MO_ABX,MO_IMP
                           -                 .BYTE   MO_IMM,MO_IZX,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_IMP ; E
                           -                 .BYTE   MO_IMP,MO_IMM,MO_IMP,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_IMP
                           -                 .BYTE   MO_REL,MO_IZY,MO_IMP,MO_IMP,MO_IMP,MO_ZPX,MO_ZPX,MO_IMP ; F
                           -                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_IMP,MO_ABX,MO_ABX,MO_IMP
                                             .ENDIF
                             
                             ;-------------------------------------------------------------------------------
                             
                                             .IF     __65C02__
                             OPCODES:
00:F000  1C4C0000824C065E  :                 .BYTE   OP_BRK,OP_ORA,OP_ERR,OP_ERR,OP_TSB,OP_ORA,OP_ASL,OP_RMB ; 0
00:F008  504C0600824C0608  :                 .BYTE   OP_PHP,OP_ORA,OP_ASL,OP_ERR,OP_TSB,OP_ORA,OP_ASL,OP_BBR
00:F010  184C4C00804C065E  :                 .BYTE   OP_BPL,OP_ORA,OP_ORA,OP_ERR,OP_TRB,OP_ORA,OP_ASL,OP_RMB ; 1
00:F018  224C3800804C0608  :                 .BYTE   OP_CLC,OP_ORA,OP_INC,OP_ERR,OP_TRB,OP_ORA,OP_ASL,OP_BBR
00:F020  400400001204605E  :                 .BYTE   OP_JSR,OP_AND,OP_ERR,OP_ERR,OP_BIT,OP_AND,OP_ROL,OP_RMB ; 2
00:F028  5804600012046008  :                 .BYTE   OP_PLP,OP_AND,OP_ROL,OP_ERR,OP_BIT,OP_AND,OP_ROL,OP_BBR
00:F030  160404001204605E  :                 .BYTE   OP_BMI,OP_AND,OP_AND,OP_ERR,OP_BIT,OP_AND,OP_ROL,OP_RMB ; 3
00:F038  6A04300012046008  :                 .BYTE   OP_SEC,OP_AND,OP_DEC,OP_ERR,OP_BIT,OP_AND,OP_ROL,OP_BBR
00:F040  643600000036485E  :                 .BYTE   OP_RTI,OP_EOR,OP_ERR,OP_ERR,OP_ERR,OP_EOR,OP_LSR,OP_RMB ; 4
00:F048  4E3648003E364808  :                 .BYTE   OP_PHA,OP_EOR,OP_LSR,OP_ERR,OP_JMP,OP_EOR,OP_LSR,OP_BBR
00:F050  1E3636000036485E  :                 .BYTE   OP_BVC,OP_EOR,OP_EOR,OP_ERR,OP_ERR,OP_EOR,OP_LSR,OP_RMB ; 5
00:F058  2636540000364808  :                 .BYTE   OP_CLI,OP_EOR,OP_PHY,OP_ERR,OP_ERR,OP_EOR,OP_LSR,OP_BBR
00:F060  660200007A02625E  :                 .BYTE   OP_RTS,OP_ADC,OP_ERR,OP_ERR,OP_STZ,OP_ADC,OP_ROR,OP_RMB ; 6
00:F068  560262003E026208  :                 .BYTE   OP_PLA,OP_ADC,OP_ROR,OP_ERR,OP_JMP,OP_ADC,OP_ROR,OP_BBR
00:F070  200202007A02625E  :                 .BYTE   OP_BVS,OP_ADC,OP_ADC,OP_ERR,OP_STZ,OP_ADC,OP_ROR,OP_RMB ; 7
00:F078  6E025C003E026208  :                 .BYTE   OP_SEI,OP_ADC,OP_PLY,OP_ERR,OP_JMP,OP_ADC,OP_ROR,OP_BBR
00:F080  1A72000078727670  :                 .BYTE   OP_BRA,OP_STA,OP_ERR,OP_ERR,OP_STY,OP_STA,OP_STX,OP_SMB ; 8
00:F088  341286007872760A  :                 .BYTE   OP_DEY,OP_BIT,OP_TXA,OP_ERR,OP_STY,OP_STA,OP_STX,OP_BBS
00:F090  0C72720078727670  :                 .BYTE   OP_BCC,OP_STA,OP_STA,OP_ERR,OP_STY,OP_STA,OP_STX,OP_SMB ; 9
00:F098  8A7288007A727A0A  :                 .BYTE   OP_TYA,OP_STA,OP_TXS,OP_ERR,OP_STZ,OP_STA,OP_STZ,OP_BBS
00:F0A0  4642440046424470  :                 .BYTE   OP_LDY,OP_LDA,OP_LDX,OP_ERR,OP_LDY,OP_LDA,OP_LDX,OP_SMB ; A
00:F0A8  7E427C004642440A  :                 .BYTE   OP_TAY,OP_LDA,OP_TAX,OP_ERR,OP_LDY,OP_LDA,OP_LDX,OP_BBS
00:F0B0  0E42420046424470  :                 .BYTE   OP_BCS,OP_LDA,OP_LDA,OP_ERR,OP_LDY,OP_LDA,OP_LDX,OP_SMB ; B
00:F0B8  284284004642440A  :                 .BYTE   OP_CLV,OP_LDA,OP_TSX,OP_ERR,OP_LDY,OP_LDA,OP_LDX,OP_BBS
00:F0C0  2E2A00002E2A3070  :                 .BYTE   OP_CPY,OP_CMP,OP_ERR,OP_ERR,OP_CPY,OP_CMP,OP_DEC,OP_SMB ; C
00:F0C8  3C2A328C2E2A300A  :                 .BYTE   OP_INY,OP_CMP,OP_DEX,OP_WAI,OP_CPY,OP_CMP,OP_DEC,OP_BBS
00:F0D0  142A2A00002A3070  :                 .BYTE   OP_BNE,OP_CMP,OP_CMP,OP_ERR,OP_ERR,OP_CMP,OP_DEC,OP_SMB ; D
00:F0D8  242A5274002A300A  :                 .BYTE   OP_CLD,OP_CMP,OP_PHX,OP_STP,OP_ERR,OP_CMP,OP_DEC,OP_BBS
00:F0E0  2C6800002C683870  :                 .BYTE   OP_CPX,OP_SBC,OP_ERR,OP_ERR,OP_CPX,OP_SBC,OP_INC,OP_SMB ; E
00:F0E8  3A684A002C68380A  :                 .BYTE   OP_INX,OP_SBC,OP_NOP,OP_ERR,OP_CPX,OP_SBC,OP_INC,OP_BBS
00:F0F0  1068680000683870  :                 .BYTE   OP_BEQ,OP_SBC,OP_SBC,OP_ERR,OP_ERR,OP_SBC,OP_INC,OP_SMB ; F
00:F0F8  6C685A000068380A  :                 .BYTE   OP_SED,OP_SBC,OP_PLX,OP_ERR,OP_ERR,OP_SBC,OP_INC,OP_BBS
                             
                             MODES:
00:F100  0289020001010101  :                 .BYTE   MO_IMM,MO_IZX,MO_IMM,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_ZPG ; 0
00:F108  0002100003030361  :                 .BYTE   MO_IMP,MO_IMM,MO_ACC,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_BRL
00:F110  4085810001050501  :                 .BYTE   MO_REL,MO_IZY,MO_IZP,MO_IMP,MO_ZPG,MO_ZPX,MO_ZPX,MO_ZPG ; 1
00:F118  00071000030B0B61  :                 .BYTE   MO_IMP,MO_ABY,MO_ACC,MO_IMP,MO_ABS,MO_ABX,MO_ABX,MO_BRL
00:F120  0389000001010101  :                 .BYTE   MO_ABS,MO_IZX,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_ZPG ; 2
00:F128  0002100003030361  :                 .BYTE   MO_IMP,MO_IMM,MO_ACC,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_BRL

Portable 65xx Assembler [16.06]

00:F130  4085810005050501  :                 .BYTE   MO_REL,MO_IZY,MO_IZP,MO_IMP,MO_ZPX,MO_ZPX,MO_ZPX,MO_ZPG ; 3
00:F138  000710000B0B0B61  :                 .BYTE   MO_IMP,MO_ABY,MO_ACC,MO_IMP,MO_ABX,MO_ABX,MO_ABX,MO_BRL
00:F140  0089000000010101  :                 .BYTE   MO_IMP,MO_IZX,MO_IMP,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG ; 4
00:F148  0002100003030361  :                 .BYTE   MO_IMP,MO_IMM,MO_ACC,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_BRL
00:F150  4085810000050501  :                 .BYTE   MO_REL,MO_IZY,MO_IZP,MO_IMP,MO_IMP,MO_ZPX,MO_ZPX,MO_ZPG ; 5
00:F158  00070000000B0B61  :                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_IMP,MO_ABX,MO_ABX,MO_BRL
00:F160  0089000001010101  :                 .BYTE   MO_IMP,MO_IZX,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_ZPG ; 6
00:F168  0002100083030361  :                 .BYTE   MO_IMP,MO_IMM,MO_ACC,MO_IMP,MO_IAB,MO_ABS,MO_ABS,MO_BRL
00:F170  4085810005050501  :                 .BYTE   MO_REL,MO_IZY,MO_IZP,MO_IMP,MO_ZPX,MO_ZPX,MO_ZPX,MO_ZPG ; 7
00:F178  000700008B0B0B61  :                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_IAX,MO_ABX,MO_ABX,MO_BRL
00:F180  4089000001010101  :                 .BYTE   MO_REL,MO_IZX,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_ZPG ; 8
00:F188  0002000003030361  :                 .BYTE   MO_IMP,MO_IMM,MO_IMP,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_BRL
00:F190  4085810005050501  :                 .BYTE   MO_REL,MO_IZY,MO_IZP,MO_IMP,MO_ZPX,MO_ZPX,MO_ZPY,MO_ZPG ; 9
00:F198  00070000030B0B61  :                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_ABS,MO_ABX,MO_ABX,MO_BRL
00:F1A0  0289020001010101  :                 .BYTE   MO_IMM,MO_IZX,MO_IMM,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_ZPG ; A
00:F1A8  0002000003030361  :                 .BYTE   MO_IMP,MO_IMM,MO_IMP,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_BRL
00:F1B0  4085810005050501  :                 .BYTE   MO_REL,MO_IZY,MO_IZP,MO_IMP,MO_ZPX,MO_ZPX,MO_ZPY,MO_ZPG ; B
00:F1B8  000700000B0B0761  :                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_ABX,MO_ABX,MO_ABY,MO_BRL
00:F1C0  0289000001010101  :                 .BYTE   MO_IMM,MO_IZX,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_ZPG ; C
00:F1C8  0002000003030361  :                 .BYTE   MO_IMP,MO_IMM,MO_IMP,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_BRL
00:F1D0  4085810000050501  :                 .BYTE   MO_REL,MO_IZY,MO_IZP,MO_IMP,MO_IMP,MO_ZPX,MO_ZPX,MO_ZPG ; D
00:F1D8  00070000000B0B61  :                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_IMP,MO_ABX,MO_ABX,MO_BRL
00:F1E0  0289000001010101  :                 .BYTE   MO_IMM,MO_IZX,MO_IMP,MO_IMP,MO_ZPG,MO_ZPG,MO_ZPG,MO_ZPG ; E
00:F1E8  0002000003030361  :                 .BYTE   MO_IMP,MO_IMM,MO_IMP,MO_IMP,MO_ABS,MO_ABS,MO_ABS,MO_BRL
00:F1F0  4085810000050501  :                 .BYTE   MO_REL,MO_IZY,MO_IZP,MO_IMP,MO_IMP,MO_ZPX,MO_ZPX,MO_ZPG ; F
00:F1F8  00070000000B0B61  :                 .BYTE   MO_IMP,MO_ABY,MO_IMP,MO_IMP,MO_IMP,MO_ABX,MO_ABX,MO_BRL
                                             .ENDIF
                             
                             ;-------------------------------------------------------------------------------
                             
                             SQUEEZE         .MACRO  CH1,CH2,CH3
                                             .WORD   ((((CH3 & $1F) << 5)|(CH2 & $1F)) << 5)|(CH1 & $1F)
                                             .ENDM
                             
                             MNEMONICS:
                                             SQUEEZE '?','?','?'
00:F200  FF7F              +                 .WORD   (((('?' & $1F) << 5)|('?' & $1F)) << 5)|('?' & $1F)
                                             SQUEEZE 'A','D','C'
00:F202  810C              +                 .WORD   (((('C' & $1F) << 5)|('D' & $1F)) << 5)|('A' & $1F)
                                             SQUEEZE 'A','N','D'
00:F204  C111              +                 .WORD   (((('D' & $1F) << 5)|('N' & $1F)) << 5)|('A' & $1F)
                                             SQUEEZE 'A','S','L'
00:F206  6132              +                 .WORD   (((('L' & $1F) << 5)|('S' & $1F)) << 5)|('A' & $1F)
                                             SQUEEZE 'B','B','R'
00:F208  4248              +                 .WORD   (((('R' & $1F) << 5)|('B' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','B','S'
00:F20A  424C              +                 .WORD   (((('S' & $1F) << 5)|('B' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','C','C'
00:F20C  620C              +                 .WORD   (((('C' & $1F) << 5)|('C' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','C','S'
00:F20E  624C              +                 .WORD   (((('S' & $1F) << 5)|('C' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','E','Q'
00:F210  A244              +                 .WORD   (((('Q' & $1F) << 5)|('E' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','I','T'

Portable 65xx Assembler [16.06]

00:F212  2251              +                 .WORD   (((('T' & $1F) << 5)|('I' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','N','E'
00:F214  C215              +                 .WORD   (((('E' & $1F) << 5)|('N' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','M','I'
00:F216  A225              +                 .WORD   (((('I' & $1F) << 5)|('M' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','P','L'
00:F218  0232              +                 .WORD   (((('L' & $1F) << 5)|('P' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','R','A'
00:F21A  4206              +                 .WORD   (((('A' & $1F) << 5)|('R' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','R','K'
00:F21C  422E              +                 .WORD   (((('K' & $1F) << 5)|('R' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','V','C'
00:F21E  C20E              +                 .WORD   (((('C' & $1F) << 5)|('V' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'B','V','S'
00:F220  C24E              +                 .WORD   (((('S' & $1F) << 5)|('V' & $1F)) << 5)|('B' & $1F)
                                             SQUEEZE 'C','L','C'
00:F222  830D              +                 .WORD   (((('C' & $1F) << 5)|('L' & $1F)) << 5)|('C' & $1F)
                                             SQUEEZE 'C','L','D'
00:F224  8311              +                 .WORD   (((('D' & $1F) << 5)|('L' & $1F)) << 5)|('C' & $1F)
                                             SQUEEZE 'C','L','I'
00:F226  8325              +                 .WORD   (((('I' & $1F) << 5)|('L' & $1F)) << 5)|('C' & $1F)
                                             SQUEEZE 'C','L','V'
00:F228  8359              +                 .WORD   (((('V' & $1F) << 5)|('L' & $1F)) << 5)|('C' & $1F)
                                             SQUEEZE 'C','M','P'
00:F22A  A341              +                 .WORD   (((('P' & $1F) << 5)|('M' & $1F)) << 5)|('C' & $1F)
                                             SQUEEZE 'C','P','X'
00:F22C  0362              +                 .WORD   (((('X' & $1F) << 5)|('P' & $1F)) << 5)|('C' & $1F)
                                             SQUEEZE 'C','P','Y'
00:F22E  0366              +                 .WORD   (((('Y' & $1F) << 5)|('P' & $1F)) << 5)|('C' & $1F)
                                             SQUEEZE 'D','E','C'
00:F230  A40C              +                 .WORD   (((('C' & $1F) << 5)|('E' & $1F)) << 5)|('D' & $1F)
                                             SQUEEZE 'D','E','X'
00:F232  A460              +                 .WORD   (((('X' & $1F) << 5)|('E' & $1F)) << 5)|('D' & $1F)
                                             SQUEEZE 'D','E','Y'
00:F234  A464              +                 .WORD   (((('Y' & $1F) << 5)|('E' & $1F)) << 5)|('D' & $1F)
                                             SQUEEZE 'E','O','R'
00:F236  E549              +                 .WORD   (((('R' & $1F) << 5)|('O' & $1F)) << 5)|('E' & $1F)
                                             SQUEEZE 'I','N','C'
00:F238  C90D              +                 .WORD   (((('C' & $1F) << 5)|('N' & $1F)) << 5)|('I' & $1F)
                                             SQUEEZE 'I','N','X'
00:F23A  C961              +                 .WORD   (((('X' & $1F) << 5)|('N' & $1F)) << 5)|('I' & $1F)
                                             SQUEEZE 'I','N','Y'
00:F23C  C965              +                 .WORD   (((('Y' & $1F) << 5)|('N' & $1F)) << 5)|('I' & $1F)
                                             SQUEEZE 'J','M','P'
00:F23E  AA41              +                 .WORD   (((('P' & $1F) << 5)|('M' & $1F)) << 5)|('J' & $1F)
                                             SQUEEZE 'J','S','R'
00:F240  6A4A              +                 .WORD   (((('R' & $1F) << 5)|('S' & $1F)) << 5)|('J' & $1F)
                                             SQUEEZE 'L','D','A'
00:F242  8C04              +                 .WORD   (((('A' & $1F) << 5)|('D' & $1F)) << 5)|('L' & $1F)
                                             SQUEEZE 'L','D','X'
00:F244  8C60              +                 .WORD   (((('X' & $1F) << 5)|('D' & $1F)) << 5)|('L' & $1F)
                                             SQUEEZE 'L','D','Y'
00:F246  8C64              +                 .WORD   (((('Y' & $1F) << 5)|('D' & $1F)) << 5)|('L' & $1F)
                                             SQUEEZE 'L','S','R'

Portable 65xx Assembler [16.06]

00:F248  6C4A              +                 .WORD   (((('R' & $1F) << 5)|('S' & $1F)) << 5)|('L' & $1F)
                                             SQUEEZE 'N','O','P'
00:F24A  EE41              +                 .WORD   (((('P' & $1F) << 5)|('O' & $1F)) << 5)|('N' & $1F)
                                             SQUEEZE 'O','R','A'
00:F24C  4F06              +                 .WORD   (((('A' & $1F) << 5)|('R' & $1F)) << 5)|('O' & $1F)
                                             SQUEEZE 'P','H','A'
00:F24E  1005              +                 .WORD   (((('A' & $1F) << 5)|('H' & $1F)) << 5)|('P' & $1F)
                                             SQUEEZE 'P','H','P'
00:F250  1041              +                 .WORD   (((('P' & $1F) << 5)|('H' & $1F)) << 5)|('P' & $1F)
                                             SQUEEZE 'P','H','X'
00:F252  1061              +                 .WORD   (((('X' & $1F) << 5)|('H' & $1F)) << 5)|('P' & $1F)
                                             SQUEEZE 'P','H','Y'
00:F254  1065              +                 .WORD   (((('Y' & $1F) << 5)|('H' & $1F)) << 5)|('P' & $1F)
                                             SQUEEZE 'P','L','A'
00:F256  9005              +                 .WORD   (((('A' & $1F) << 5)|('L' & $1F)) << 5)|('P' & $1F)
                                             SQUEEZE 'P','L','P'
00:F258  9041              +                 .WORD   (((('P' & $1F) << 5)|('L' & $1F)) << 5)|('P' & $1F)
                                             SQUEEZE 'P','L','X'
00:F25A  9061              +                 .WORD   (((('X' & $1F) << 5)|('L' & $1F)) << 5)|('P' & $1F)
                                             SQUEEZE 'P','L','Y'
00:F25C  9065              +                 .WORD   (((('Y' & $1F) << 5)|('L' & $1F)) << 5)|('P' & $1F)
                                             SQUEEZE 'R','M','B'
00:F25E  B209              +                 .WORD   (((('B' & $1F) << 5)|('M' & $1F)) << 5)|('R' & $1F)
                                             SQUEEZE 'R','O','L'
00:F260  F231              +                 .WORD   (((('L' & $1F) << 5)|('O' & $1F)) << 5)|('R' & $1F)
                                             SQUEEZE 'R','O','R'
00:F262  F249              +                 .WORD   (((('R' & $1F) << 5)|('O' & $1F)) << 5)|('R' & $1F)
                                             SQUEEZE 'R','T','I'
00:F264  9226              +                 .WORD   (((('I' & $1F) << 5)|('T' & $1F)) << 5)|('R' & $1F)
                                             SQUEEZE 'R','T','S'
00:F266  924E              +                 .WORD   (((('S' & $1F) << 5)|('T' & $1F)) << 5)|('R' & $1F)
                                             SQUEEZE 'S','B','C'
00:F268  530C              +                 .WORD   (((('C' & $1F) << 5)|('B' & $1F)) << 5)|('S' & $1F)
                                             SQUEEZE 'S','E','C'
00:F26A  B30C              +                 .WORD   (((('C' & $1F) << 5)|('E' & $1F)) << 5)|('S' & $1F)
                                             SQUEEZE 'S','E','D'
00:F26C  B310              +                 .WORD   (((('D' & $1F) << 5)|('E' & $1F)) << 5)|('S' & $1F)
                                             SQUEEZE 'S','E','I'
00:F26E  B324              +                 .WORD   (((('I' & $1F) << 5)|('E' & $1F)) << 5)|('S' & $1F)
                                             SQUEEZE 'S','M','B'
00:F270  B309              +                 .WORD   (((('B' & $1F) << 5)|('M' & $1F)) << 5)|('S' & $1F)
                                             SQUEEZE 'S','T','A'
00:F272  9306              +                 .WORD   (((('A' & $1F) << 5)|('T' & $1F)) << 5)|('S' & $1F)
                                             SQUEEZE 'S','T','P'
00:F274  9342              +                 .WORD   (((('P' & $1F) << 5)|('T' & $1F)) << 5)|('S' & $1F)
                                             SQUEEZE 'S','T','X'
00:F276  9362              +                 .WORD   (((('X' & $1F) << 5)|('T' & $1F)) << 5)|('S' & $1F)
                                             SQUEEZE 'S','T','Y'
00:F278  9366              +                 .WORD   (((('Y' & $1F) << 5)|('T' & $1F)) << 5)|('S' & $1F)
                                             SQUEEZE 'S','T','Z'
00:F27A  936A              +                 .WORD   (((('Z' & $1F) << 5)|('T' & $1F)) << 5)|('S' & $1F)
                                             SQUEEZE 'T','A','X'
00:F27C  3460              +                 .WORD   (((('X' & $1F) << 5)|('A' & $1F)) << 5)|('T' & $1F)
                                             SQUEEZE 'T','A','Y'

Portable 65xx Assembler [16.06]

00:F27E  3464              +                 .WORD   (((('Y' & $1F) << 5)|('A' & $1F)) << 5)|('T' & $1F)
                                             SQUEEZE 'T','R','B'
00:F280  540A              +                 .WORD   (((('B' & $1F) << 5)|('R' & $1F)) << 5)|('T' & $1F)
                                             SQUEEZE 'T','S','B'
00:F282  740A              +                 .WORD   (((('B' & $1F) << 5)|('S' & $1F)) << 5)|('T' & $1F)
                                             SQUEEZE 'T','S','X'
00:F284  7462              +                 .WORD   (((('X' & $1F) << 5)|('S' & $1F)) << 5)|('T' & $1F)
                                             SQUEEZE 'T','X','A'
00:F286  1407              +                 .WORD   (((('A' & $1F) << 5)|('X' & $1F)) << 5)|('T' & $1F)
                                             SQUEEZE 'T','X','S'
00:F288  144F              +                 .WORD   (((('S' & $1F) << 5)|('X' & $1F)) << 5)|('T' & $1F)
                                             SQUEEZE 'T','Y','A'
00:F28A  3407              +                 .WORD   (((('A' & $1F) << 5)|('Y' & $1F)) << 5)|('T' & $1F)
                                             SQUEEZE 'W','A','I'
00:F28C  3724              +                 .WORD   (((('I' & $1F) << 5)|('A' & $1F)) << 5)|('W' & $1F)
                             
                             ;===============================================================================
                             ;
                             ;-------------------------------------------------------------------------------
                             
                             BREAK:
00:F28E  58                :                 CLI                     ; Allow interrupts
00:F28F  68                :                 PLA
00:F290  85F2              :                 STA     Y_REG
00:F292  68                :                 PLA
00:F293  85F1              :                 STA     X_REG
00:F295  68                :                 PLA
00:F296  85F0              :                 STA     A_REG
00:F298  68                :                 PLA
00:F299  85F3              :                 STA     P_REG
00:F29B  38                :                 SEC
00:F29C  68                :                 PLA
00:F29D  E902              :                 SBC     #2
00:F29F  85F4              :                 STA     PC_REG+0
00:F2A1  68                :                 PLA
00:F2A2  E900              :                 SBC     #0
00:F2A4  85F5              :                 STA     PC_REG+1
                             
                             REGISTERS:
00:F2A6  207CF6            :                 JSR     CRLF
00:F2A9  A200              :                 LDX     #PC_STR
00:F2AB  2086F6            :                 JSR     SHOW_STR
00:F2AE  A5F5              :                 LDA     PC_REG+1
00:F2B0  2056F6            :                 JSR     HEX2
00:F2B3  A5F4              :                 LDA     PC_REG+0
00:F2B5  2056F6            :                 JSR     HEX2
                             
00:F2B8  A20D              :                 LDX     #A_STR
00:F2BA  2086F6            :                 JSR     SHOW_STR
00:F2BD  A5F0              :                 LDA     A_REG
00:F2BF  2056F6            :                 JSR     HEX2
                             
00:F2C2  A211              :                 LDX     #X_STR
00:F2C4  2086F6            :                 JSR     SHOW_STR

Portable 65xx Assembler [16.06]

00:F2C7  A5F1              :                 LDA     X_REG
00:F2C9  2056F6            :                 JSR     HEX2
                             
00:F2CC  A215              :                 LDX     #Y_STR
00:F2CE  2086F6            :                 JSR     SHOW_STR
00:F2D1  A5F2              :                 LDA     Y_REG
00:F2D3  2056F6            :                 JSR     HEX2
                                             
00:F2D6  A209              :                 LDX     #P_STR
00:F2D8  2086F6            :                 JSR     SHOW_STR
00:F2DB  A207              :                 LDX     #7
                                             REPEAT
00:F2DD  A02E              :                  LDY    #'.'
00:F2DF  BD70F7            :                  LDA    BITS,X
00:F2E2  24F3              :                  BIT    P_REG
00:F2E4  F003              :                  IF     NE
00:F2E6  BC68F7            :                   LDY   FLAG,X
                                              ENDIF
00:F2E9  98                :                  TYA
00:F2EA  201EFF            :                  JSR    UART_TX
00:F2ED  CA                :                  DEX
00:F2EE  10ED              :                 UNTIL MI                  
                                             
00:F2F0  A204              :                 LDX     #SP_STR
00:F2F2  2086F6            :                 JSR     SHOW_STR
00:F2F5  BA                :                 TSX
00:F2F6  8A                :                 TXA
00:F2F7  2056F6            :                 JSR     HEX2
                             
                             COMMAND:
                                             .IF     __65C02__
00:F2FA  64F6              :                 STZ     CMD_LEN         ; Mark the buffer as empty
                                             .ELSE
                           -                 LDA     #0              ; Mark the buffer as empty
                           -                 STA     CMD_LEN
                                             .ENDIF
                             
                             PROMPT:
00:F2FC  207CF6            :                 JSR     CRLF            ; Move cursor to next line
00:F2FF  A92E              :                 LDA     #'.'            ; And output the prompt
00:F301  201EFF            :                 JSR     UART_TX
                             
00:F304  A200              :                 LDX     #0
                                             REPEAT
00:F306  E4F6              :                  CPX    CMD_LEN         ; Any saved characters to display?
00:F308  F009              :                  BREAK  EQ              ; No
00:F30A  BD8002            :                  LDA    BUFFER,X        ; Yes, print from the buffer
00:F30D  201EFF            :                  JSR    UART_TX
00:F310  E8                :                  INX
00:F311  80F3              :                 FOREVER
                                             
00:F313  2018FF            :                 JSR     XON
                                             REPEAT
00:F316  203BFF            :                  JSR    UART_RX         ; Wait for some user input

Portable 65xx Assembler [16.06]

                                              
00:F319  C91B              :                  CMP    #ESC            ; Cancel input?
00:F31B  D002              :                  IF     EQ
00:F31D  F0DB              :                   BEQ   COMMAND         ; Yes
                                              ENDIF
                             
00:F31F  C908              :                  CMP    #BS             ; Backspace?
00:F321  D012              :                  IF     EQ
00:F323  E000              : BACKSPACE:        CPX   #0              ; Anything in the buffer?
00:F325  F00C              :                   IF    NE
00:F327  48                :                    PHA                  ; Erase the last character
00:F328  201EFF            :                    JSR  UART_TX
00:F32B  2072F6            :                    JSR  SPACE
00:F32E  68                :                    PLA
00:F32F  201EFF            :                    JSR  UART_TX
00:F332  CA                :                    DEX
                                               ENDIF
00:F333  80E1              :                   CONTINUE
                                              ENDIF
                             
00:F335  C90D              :                  CMP    #CR             ; End of command entry?
00:F337  F022              :                  BREAK  EQ              ; Yes
                             
00:F339  C97F              :                  CMP    #DEL            ; Convert DEL into BS
00:F33B  D004              :                  IF     EQ
00:F33D  A908              :                   LDA   #BS
00:F33F  D0E2              :                   BNE   BACKSPACE
                                              ENDIF
00:F341  9007              :                  IF     CS              ; In the range $7F-$FF?
00:F343  A907              : SQUAWK:           LDA   #BEL            ; Yes, squawk!
00:F345  201EFF            :                   JSR   UART_TX
00:F348  80CC              :                   CONTINUE
                                              ENDIF
                             
00:F34A  C920              :                  CMP    #' '            ; In the range $00-$1F?
00:F34C  90F5              :                  BCC    SQUAWK          ; Yes, squawk!
                             
00:F34E  E07F              :                  CPX    #CMD_SIZE-1     ; Command buffer full?
00:F350  B0F1              :                  BCS    SQUAWK          ; Yes, squawk!
                             
00:F352  9D8002            :                  STA    BUFFER,X        ; Save the character
00:F355  E8                :                  INX                    ; Bump the count
00:F356  201EFF            :                  JSR    UART_TX         ; And echo to terminal
00:F359  80BB              :                 FOREVER
00:F35B  201CFF            :                 JSR     XOFF
                             
00:F35E  86F6              :                 STX     CMD_LEN         ; Save the command length
00:F360  A200              :                 LDX     #0              ; Set character offset to start
00:F362  20C7F4            :                 JSR     SKIP_CHAR       ; And get first character
00:F365  B093              :                 BCS     COMMAND
                             
                             ;===============================================================================
                             ; 'A' - Assemble
                             ;-------------------------------------------------------------------------------

Portable 65xx Assembler [16.06]

                             
00:F367  C941              :                 CMP     #'A'
00:F369  D000              :                 IF      EQ
                                             ENDIF
                             
                             ;===============================================================================
                             ; 'D' - Disassemble Memory
                             ;-------------------------------------------------------------------------------
                             
00:F36B  C944              :                 CMP     #'D'
00:F36D  D035              :                 IF      EQ
00:F36F  20D3F4            :                  JSR    GET_WORD
00:F372  B02D              :                  IF     CC
00:F374  205DF4            :                   JSR   SET_ADDR_S
00:F377  2066F4            :                   JSR   SET_ADDR_E
00:F37A  20D3F4            :                   JSR   GET_WORD
00:F37D  B005              :                   IF    CC
00:F37F  2066F4            :                    JSR  SET_ADDR_E
00:F382  8002              :                   ELSE
00:F384  E6FA              :                    INC  ADDR_E+1
                                               ENDIF
                                               
                                               REPEAT
00:F386  207CF6            :                    JSR  CRLF            ; Print the memory address
00:F389  A5F8              :                    LDA  ADDR_S+1
00:F38B  2056F6            :                    JSR  HEX2
00:F38E  A5F7              :                    LDA  ADDR_S+0
00:F390  2056F6            :                    JSR  HEX2
                                                
00:F393  2037F5            :                    JSR  DISASSEMBLE
00:F396  206FF4            :                    JSR  BUMP_ADDR                  
00:F399  2079F4            :                    JSR  CHECK_END
00:F39C  30E8              :                   UNTIL PL
00:F39E  4CFAF2            :                   JMP   COMMAND
                                              ENDIF
00:F3A1  4C55F4            :                  JMP    ERROR           
                                             ENDIF
                                             
                             ;===============================================================================
                             ; 'G' - Go
                             ;-------------------------------------------------------------------------------
                             
00:F3A4  C947              :                 CMP     #'G'
00:F3A6  D010              :                 IF      EQ
                             
00:F3A8  A5F5              :                  LDA    PC_REG+1        ; Push the target address
00:F3AA  48                :                  PHA
00:F3AB  A5F4              :                  LDA    PC_REG+0
00:F3AD  48                :                  PHA
00:F3AE  A5F3              :                  LDA    P_REG           ; And status flags
00:F3B0  48                :                  PHA
00:F3B1  A5F0              :                  LDA    A_REG           ; Reload A, X and Y
00:F3B3  A6F1              :                  LDX    X_REG
00:F3B5  A4F2              :                  LDY    Y_REG

Portable 65xx Assembler [16.06]

00:F3B7  40                :                  RTI                    ; Then go to code
                                             ENDIF
                             
                             ;===============================================================================
                             ; 'M' - Show Memory
                             ;-------------------------------------------------------------------------------                
                             
00:F3B8  C94D              :                 CMP     #'M'
00:F3BA  D05E              :                 IF      EQ
00:F3BC  20D3F4            :                  JSR    GET_WORD
00:F3BF  B056              :                  IF     CC
00:F3C1  205DF4            :                   JSR   SET_ADDR_S
00:F3C4  2066F4            :                   JSR   SET_ADDR_E
00:F3C7  20D3F4            :                   JSR   GET_WORD
00:F3CA  B005              :                   IF    CC
00:F3CC  2066F4            :                    JSR  SET_ADDR_E
00:F3CF  8002              :                   ELSE
00:F3D1  E6FA              :                    INC  ADDR_E+1
                                               ENDIF
                                               
                                               REPEAT
00:F3D3  207CF6            :                    JSR  CRLF            ; Print the memory address
00:F3D6  A5F8              :                    LDA  ADDR_S+1
00:F3D8  2056F6            :                    JSR  HEX2
00:F3DB  A5F7              :                    LDA  ADDR_S+0
00:F3DD  2056F6            :                    JSR  HEX2
                                                
00:F3E0  A000              :                    LDY  #0              ; Dump 16 bytes of data
                                                REPEAT
00:F3E2  2072F6            :                     JSR SPACE
00:F3E5  B1F7              :                     LDA (ADDR_S),Y
00:F3E7  C8                :                     INY
00:F3E8  2056F6            :                     JSR HEX2
00:F3EB  C010              :                     CPY #16
00:F3ED  D0F3              :                    UNTIL EQ
                                                
00:F3EF  2072F6            :                    JSR  SPACE           ; Then show as characters
00:F3F2  2077F6            :                    JSR  BAR
00:F3F5  A000              :                    LDY  #0
                                                REPEAT
00:F3F7  B1F7              :                     LDA (ADDR_S),Y
00:F3F9  C8                :                     INY
00:F3FA  202BF5            :                     JSR IS_PRINTABLE
00:F3FD  B002              :                     IF CC
00:F3FF  A92E              :                      LDA #'.'
                                                 ENDIF
00:F401  201EFF            :                     JSR UART_TX
00:F404  C010              :                     CPY #16
00:F406  D0EF              :                    UNTIL EQ
00:F408  2077F6            :                    JSR  BAR
                                                
00:F40B  98                :                    TYA
00:F40C  206FF4            :                    JSR  BUMP_ADDR
00:F40F  2079F4            :                    JSR  CHECK_END

Portable 65xx Assembler [16.06]

00:F412  30BF              :                   UNTIL PL
00:F414  4CFAF2            :                   JMP   COMMAND
                                              ENDIF
00:F417  4C55F4            :                  JMP    ERROR
                                             ENDIF
                             
                             ;===============================================================================
                             ; 'R' - Show Registers
                             ;-------------------------------------------------------------------------------
                             
00:F41A  C952              :                 CMP     #'R'
00:F41C  D003              :                 IF      EQ
00:F41E  4CA6F2            :                  JMP    REGISTERS
                                             ENDIF
                                             
                             ;===============================================================================
                             ; 'S' - Load SREC
                             ;-------------------------------------------------------------------------------
                             
00:F421  C953              :                 CMP     #'S'
00:F423  D000              :                 IF      EQ
                                             ENDIF
                                             
                             ;===============================================================================
                             ; 'T' - Trace
                             ;-------------------------------------------------------------------------------
                             
00:F425  C954              :                 CMP     #'T'
00:F427  D000              :                 IF      EQ
                                             ENDIF
                                             
                             ;===============================================================================
                             ; 'W' - Write Memory
                             ;-------------------------------------------------------------------------------
                             
00:F429  C957              :                 CMP     #'W'
00:F42B  D020              :                 IF      EQ
00:F42D  20D3F4            :                  JSR    GET_WORD        ; Get the target address
00:F430  B018              :                  IF     CC
00:F432  205DF4            :                   JSR   SET_ADDR_S      ; Copy to start address
00:F435  20D7F4            :                   JSR   GET_BYTE        ; Get the value
00:F438  B010              :                   IF    CC
00:F43A  A000              :                    LDY  #0              ; Write to  memory
00:F43C  A5FB              :                    LDA  TEMP+0
00:F43E  91F7              :                    STA  (ADDR_S),Y
00:F440  A901              :                    LDA  #1              ; Increment address
00:F442  206FF4            :                    JSR  BUMP_ADDR
00:F445  A957              :                    LDA  #'W'            ; Create prompt for next byte
00:F447  4C83F4            :                    JMP  SET_PROMPT
                                               ENDIF
                                              ENDIF
00:F44A  4C55F4            :                  JMP    ERROR           ; Handle syntax errors
                                             ENDIF
                                             

Portable 65xx Assembler [16.06]

                             ;===============================================================================
                             ; '?' - Display Help
                             ;-------------------------------------------------------------------------------
                             
00:F44D  C93F              :                 CMP     #'?'
00:F44F  D004              :                 IF      EQ
00:F451  A21D              :                  LDX    #HLP_STR
00:F453  8002              :                 ELSE
00:F455  A219              : ERROR:           LDX    #ERR_STR
                                             ENDIF
00:F457  2086F6            :                 JSR     SHOW_STR
00:F45A  4CFAF2            :                 JMP     COMMAND
                             
                             ;===============================================================================
                             ;-------------------------------------------------------------------------------
                             
                             SET_ADDR_S:
00:F45D  A5FB              :                 LDA     TEMP+0
00:F45F  85F7              :                 STA     ADDR_S+0
00:F461  A5FC              :                 LDA     TEMP+1
00:F463  85F8              :                 STA     ADDR_S+1
00:F465  60                :                 RTS
                             
                             SET_ADDR_E:
00:F466  A5FB              :                 LDA     TEMP+0
00:F468  85F9              :                 STA     ADDR_E+0
00:F46A  A5FC              :                 LDA     TEMP+1
00:F46C  85FA              :                 STA     ADDR_E+1
00:F46E  60                :                 RTS
                             
                             BUMP_ADDR:
00:F46F  18                :                 CLC
00:F470  65F7              :                 ADC     ADDR_S+0
00:F472  85F7              :                 STA     ADDR_S+0
00:F474  9002              :                 IF      CS
00:F476  E6F8              :                  INC    ADDR_S+1
                                             ENDIF
00:F478  60                :                 RTS
                                             
                             CHECK_END:
00:F479  38                :                 SEC
00:F47A  A5F7              :                 LDA     ADDR_S+0
00:F47C  E5F9              :                 SBC     ADDR_E+0
00:F47E  A5F8              :                 LDA     ADDR_S+1
00:F480  E5FA              :                 SBC     ADDR_E+1
00:F482  60                :                 RTS
                             
                             ; Create a prompt string in the command buffer for the command in A using the
                             ; current value of the starting address.
                             
                             SET_PROMPT:
00:F483  A200              :                 LDX     #0              ; Clear buffer and add command letter
00:F485  20ABF4            :                 JSR     APPEND_CHAR
00:F488  A920              :                 LDA     #' '            ; Then a space

Portable 65xx Assembler [16.06]

00:F48A  20ABF4            :                 JSR     APPEND_CHAR
                                             
00:F48D  A5F8              :                 LDA     ADDR_S+1        ; Followed by the address
00:F48F  209FF4            :                 JSR     APPEND_HEX2
00:F492  A5F7              :                 LDA     ADDR_S+0
00:F494  209FF4            :                 JSR     APPEND_HEX2
00:F497  A920              :                 LDA     #' '            ; And another space
00:F499  20ABF4            :                 JSR     APPEND_CHAR
00:F49C  4CFCF2            :                 JMP     PROMPT          ; Then output it
                             
                             ; Convert the byte in A into hexadecimal digits and append to the command buffer.               
                                             
                             APPEND_HEX2:
00:F49F  48                :                 PHA
00:F4A0  4A                :                 LSR     A
00:F4A1  4A                :                 LSR     A
00:F4A2  4A                :                 LSR     A
00:F4A3  4A                :                 LSR     A
00:F4A4  20A8F4            :                 JSR     APPEND_HEX
00:F4A7  68                :                 PLA
                             APPEND_HEX:
00:F4A8  2065F6            :                 JSR     TO_HEX
                             
                             ; Append the character in A to the command buffer to create the next prompt
                             ; string.
                             
                             APPEND_CHAR:
00:F4AB  9D8002            :                 STA     BUFFER,X
00:F4AE  E8                :                 INX
00:F4AF  86F6              :                 STX     CMD_LEN
00:F4B1  60                :                 RTS
                                                             
                             ;===============================================================================
                             ; Parsing Utilities
                             ;-------------------------------------------------------------------------------
                             
                             ; Get the next characater from the command buffer indicated by the X register
                             ; and convert it to UPPER case. If the carry is set then the end of the buffer
                             ; has been reached.
                             
                             NEXT_CHAR:
00:F4B2  E4F6              :                 CPX     CMD_LEN         ; Reached end of buffer
00:F4B4  9001              :                 IF      CS
00:F4B6  60                :                  RTS
                                             ENDIF
00:F4B7  BD8002            :                 LDA     BUFFER,X
00:F4BA  E8                :                 INX
                             
                             ; Convert the character in A to upper case.
                             
                             TO_UPPER:
00:F4BB  C961              :                 CMP     #'a'
00:F4BD  9006              :                 IF      CS
00:F4BF  C97B              :                  CMP    #'z'+1

Portable 65xx Assembler [16.06]

00:F4C1  B002              :                  IF     CC
00:F4C3  295F              :                   AND   #$5F
                                              ENDIF
                                             ENDIF
00:F4C5  18                :                 CLC
00:F4C6  60                :                 RTS
                                             
                             SKIP_CHAR:
                                             REPEAT
00:F4C7  20B2F4            :                  JSR    NEXT_CHAR
00:F4CA  9001              :                  IF     CS
00:F4CC  60                :                   RTS
                                              ENDIF
00:F4CD  C920              :                  CMP    #' '
00:F4CF  F0F6              :                 UNTIL   NE
00:F4D1  18                :                 CLC
00:F4D2  60                :                 RTS
                             
                             ; Parse a word from the command buffer and store it at 0,Y. Return if the
                             ; carry set if there is a syntax error.
                             
                             GET_WORD:
00:F4D3  A004              :                 LDY     #4              ; Set maximim number of nybbles
00:F4D5  D002              :                 BNE     GET_BYTE+2
                             
                             
                             ; Parse a word from the command buffer and store it at 0,Y. Return if the
                             ; carry set if there is a syntax error.
                             
                             GET_BYTE:
00:F4D7  A002              :                 LDY     #2              ; Set maximum number of nybble
00:F4D9  84FD              :                 STY     COUNT
                                             
                                             .IF     __65C02__
00:F4DB  64FB              :                 STZ     TEMP+0          ; Clear conversion area
00:F4DD  64FC              :                 STZ     TEMP+1
                                             .ELSE
                           -                 LDY     #0
                           -                 STY     TEMP+0          ; Clear conversion area
                           -                 STY     TEMP+1
                                             .ENDIF
                             
00:F4DF  20C7F4            :                 JSR     SKIP_CHAR       ; Fetch first character
00:F4E2  200AF5            :                 JSR     GET_NYBBLE      ; And try to convert
00:F4E5  9001              :                 IF      CS
00:F4E7  60                :                  RTS                    ; Syntax error
                                             ENDIF
                                             REPEAT
00:F4E8  06FB              :                  ASL    TEMP+0          ; Fold into the result
00:F4EA  26FC              :                  ROL    TEMP+1
00:F4EC  06FB              :                  ASL    TEMP+0
00:F4EE  26FC              :                  ROL    TEMP+1
00:F4F0  06FB              :                  ASL    TEMP+0
00:F4F2  26FC              :                  ROL    TEMP+1

Portable 65xx Assembler [16.06]

00:F4F4  06FB              :                  ASL    TEMP+0
00:F4F6  26FC              :                  ROL    TEMP+1
00:F4F8  05FB              :                  ORA    TEMP+0
00:F4FA  85FB              :                  STA    TEMP+0
                                              
00:F4FC  C6FD              :                  DEC    COUNT           ; Reach maximum length?
00:F4FE  F008              :                  BREAK  EQ
                                              
00:F500  20B2F4            :                  JSR    NEXT_CHAR       ; Try for another nybble
00:F503  200AF5            :                  JSR    GET_NYBBLE
00:F506  90E0              :                 UNTIL CS                
00:F508  18                :                 CLC                     ; Conversion sucessfull
00:F509  60                :                 RTS
                             
                             ;
                             ;
                             
                             GET_NYBBLE:
00:F50A  201BF5            :                 JSR     IS_HEX          ; Got a hex digit?
00:F50D  900A              :                 IF      CS
00:F50F  C941              :                  CMP    #'A'            ; Handle letters
00:F511  9002              :                  IF     CS
00:F513  E907              :                   SBC   #7
                                              ENDIF
00:F515  290F              :                  AND    #$0F            ; Skip out nybble
00:F517  18                :                  CLC                    ; Done
00:F518  60                :                  RTS
                                             ENDIF
00:F519  38                :                 SEC                     ; Set carry -- not hex
00:F51A  60                :                 RTS
                             
                             ; Return with the carry set of the character in A is a digit or 'A' thru 'F'.
                             
                             IS_HEX:
00:F51B  C93A              :                 CMP     #'9'+1
00:F51D  B003              :                 IF      CC
00:F51F  C930              :                  CMP    #'0'
00:F521  60                :                  RTS
                                             ENDIF
00:F522  C947              :                 CMP     #'F'+1
00:F524  B003              :                 IF      CC
00:F526  C941              :                  CMP    #'A'
00:F528  60                :                  RTS
                                             ENDIF
00:F529  18                :                 CLC
00:F52A  60                :                 RTS
                                             
                             IS_PRINTABLE:
00:F52B  C920              :                 CMP     #' '
00:F52D  9006              :                 IF      CS
00:F52F  C97F              :                  CMP    #DEL
00:F531  B002              :                  IF     CC
00:F533  38                :                   SEC
00:F534  60                :                   RTS

Portable 65xx Assembler [16.06]

                                              ENDIF
                                             ENDIF
00:F535  18                :                 CLC
00:F536  60                :                 RTS
                                             
                             ;===============================================================================
                             ;-------------------------------------------------------------------------------
                             
                             DISASSEMBLE:
00:F537  2072F6            :                 JSR     SPACE
00:F53A  A000              :                 LDY     #0              ; Fetch the opcode
00:F53C  B1F7              :                 LDA     (ADDR_S),Y
00:F53E  AA                :                 TAX
00:F53F  2056F6            :                 JSR     HEX2            ; And display it
                                             
00:F542  2072F6            :                 JSR     SPACE
00:F545  BD00F1            :                 LDA     MODES,X
00:F548  48                :                 PHA
00:F549  48                :                 PHA
00:F54A  2943              :                 AND     #MB_REL|MB_ABS
00:F54C  F009              :                 IF      NE
00:F54E  A001              :                  LDY    #1
00:F550  B1F7              :                  LDA    (ADDR_S),Y
00:F552  2056F6            :                  JSR    HEX2
00:F555  8003              :                 ELSE
00:F557  206FF6            :                  JSR    SPACE2
                                             ENDIF
                                             
00:F55A  2072F6            :                 JSR     SPACE
00:F55D  68                :                 PLA
00:F55E  A8                :                 TAY
00:F55F  2941              :                 AND     #MB_REL|MB_ZPG
00:F561  C941              :                 CMP     #MB_REL|MB_ZPG
00:F563  F005              :                 IF      NE
00:F565  98                :                  TYA
00:F566  2903              :                  AND    #MB_ABS
00:F568  C903              :                  CMP    #MB_ABS
                                             ENDIF
00:F56A  D009              :                 IF      EQ
00:F56C  A002              :                  LDY    #2
00:F56E  B1F7              :                  LDA    (ADDR_S),Y
00:F570  2056F6            :                  JSR    HEX2
00:F573  8003              :                 ELSE
00:F575  206FF6            :                  JSR    SPACE2
                                             ENDIF
                                             
00:F578  C8                :                 INY                     ; Save the byte count
00:F579  98                :                 TYA
00:F57A  48                :                 PHA
                             
00:F57B  2072F6            :                 JSR     SPACE
00:F57E  A000              :                 LDY     #0              ; Fetch the opcode
00:F580  B1F7              :                 LDA     (ADDR_S),Y
00:F582  AA                :                 TAX

Portable 65xx Assembler [16.06]

00:F583  BD00F0            :                 LDA     OPCODES,X
00:F586  AA                :                 TAX
00:F587  BD01F2            :                 LDA     MNEMONICS+1,X
00:F58A  85FB              :                 STA     TEMP
00:F58C  BD00F2            :                 LDA     MNEMONICS+0,X
00:F58F  203DF6            :                 JSR     EXTRACT_LETTER
00:F592  203DF6            :                 JSR     EXTRACT_LETTER
00:F595  203DF6            :                 JSR     EXTRACT_LETTER
00:F598  2072F6            :                 JSR     SPACE
                                             
00:F59B  68                :                 PLA
00:F59C  48                :                 PHA
00:F59D  2920              :                 AND     #MB_BIT
00:F59F  F010              :                 IF      NE
00:F5A1  A000              :                  LDY    #0
00:F5A3  B1F7              :                  LDA    (ADDR_S),Y
00:F5A5  2907              :                  AND    #7
00:F5A7  0930              :                  ORA    #'0'
00:F5A9  201EFF            :                  JSR    UART_TX
00:F5AC  A92C              :                  LDA    #','
00:F5AE  201EFF            :                  JSR    UART_TX
                                             ENDIF
                                             
00:F5B1  68                :                 PLA
00:F5B2  48                :                 PHA
00:F5B3  1005              :                 IF      MI
00:F5B5  A928              :                  LDA    #'('
00:F5B7  201EFF            :                  JSR    UART_TX
                                             ENDIF
                                             
00:F5BA  68                :                 PLA
00:F5BB  48                :                 PHA
00:F5BC  2903              :                 AND     #MB_ABS
00:F5BE  F022              :                 IF      NE
00:F5C0  48                :                  PHA
00:F5C1  C902              :                  CMP    #MB_IMM
00:F5C3  D005              :                  IF     EQ
00:F5C5  A923              :                   LDA   #'#'
00:F5C7  201EFF            :                   JSR   UART_TX
                                              ENDIF
00:F5CA  A924              :                  LDA    #'$'
00:F5CC  201EFF            :                  JSR    UART_TX
00:F5CF  68                :                  PLA
00:F5D0  C903              :                  CMP    #MB_ABS
00:F5D2  D007              :                  IF     EQ
00:F5D4  A002              :                   LDY   #2
00:F5D6  B1F7              :                   LDA   (ADDR_S),Y
00:F5D8  2056F6            :                   JSR   HEX2
                                              ENDIF
00:F5DB  A001              :                  LDY    #1
00:F5DD  B1F7              :                  LDA    (ADDR_S),Y
00:F5DF  2056F6            :                  JSR    HEX2
                                             ENDIF
                                             

Portable 65xx Assembler [16.06]

00:F5E2  68                :                 PLA
00:F5E3  48                :                 PHA
00:F5E4  2960              :                 AND     #MB_BIT|MB_REL
00:F5E6  C960              :                 CMP     #MB_BIT|MB_REL
00:F5E8  D005              :                 IF      EQ
00:F5EA  A92C              :                  LDA    #','
00:F5EC  201EFF            :                  JSR    UART_TX
                                             ENDIF
                                             
00:F5EF  68                :                 PLA
00:F5F0  48                :                 PHA
00:F5F1  A8                :                 TAY
00:F5F2  2940              :                 AND     #MB_REL
00:F5F4  F012              :                 IF      NE
00:F5F6  A924              :                  LDA    #'$'
00:F5F8  201EFF            :                  JSR    UART_TX
00:F5FB  98                :                  TYA
00:F5FC  A001              :                  LDY    #1
00:F5FE  2920              :                  AND    #MB_BIT
00:F600  F001              :                  IF     NE
00:F602  C8                :                   INY
                                              ENDIF
                                              
00:F603  A972              :                  LDA    #'r'
00:F605  203BFF            :                  JSR    UART_RX
                                             ENDIF
                                             
00:F608  68                :                 PLA
00:F609  48                :                 PHA
00:F60A  2910              :                 AND     #MB_ACC
00:F60C  F005              :                 IF      NE
00:F60E  A941              :                  LDA    #'A'
00:F610  201EFF            :                  JSR    UART_TX
                                             ENDIF
                                             
00:F613  68                :                 PLA
00:F614  48                :                 PHA
00:F615  2908              :                 AND     #MB_XRG
00:F617  F00A              :                 IF      NE
00:F619  A92C              :                  LDA    #','
00:F61B  201EFF            :                  JSR    UART_TX
00:F61E  A958              :                  LDA    #'X'
00:F620  201EFF            :                  JSR    UART_TX
                                             ENDIF
                                             
00:F623  68                :                 PLA
00:F624  48                :                 PHA
00:F625  1005              :                 IF      MI
00:F627  A929              :                  LDA    #')'
00:F629  201EFF            :                  JSR    UART_TX
                                             ENDIF
                                             
00:F62C  68                :                 PLA
00:F62D  2904              :                 AND     #MB_YRG

Portable 65xx Assembler [16.06]

00:F62F  F00A              :                 IF      NE
00:F631  A92C              :                  LDA    #','
00:F633  201EFF            :                  JSR    UART_TX
00:F636  A959              :                  LDA    #'Y'
00:F638  201EFF            :                  JSR    UART_TX
                                             ENDIF
                                             
00:F63B  68                :                 PLA                     ; Return the number of bytes
00:F63C  60                :                 RTS
                                             
                             EXTRACT_LETTER:
00:F63D  48                :                 PHA
00:F63E  291F              :                 AND     #$1F
00:F640  0940              :                 ORA     #'@'
00:F642  201EFF            :                 JSR     UART_TX
00:F645  68                :                 PLA
00:F646  46FB              :                 LSR     TEMP
00:F648  6A                :                 ROR     A
00:F649  46FB              :                 LSR     TEMP
00:F64B  6A                :                 ROR     A
00:F64C  46FB              :                 LSR     TEMP
00:F64E  6A                :                 ROR     A
00:F64F  46FB              :                 LSR     TEMP
00:F651  6A                :                 ROR     A
00:F652  46FB              :                 LSR     TEMP
00:F654  6A                :                 ROR     A
00:F655  60                :                 RTS
                                             
                                             
                             ;===============================================================================
                             ; Display Utilities
                             ;-------------------------------------------------------------------------------
                             
                             ; Display the byte in A as two hexadecimal digits. The values in A & Y are
                             ; destroyed.
                             
                             HEX2:
00:F656  48                :                 PHA                     ; Save a copy of the value
00:F657  4A                :                 LSR     A               ; Shift down the hi nybble
00:F658  4A                :                 LSR     A
00:F659  4A                :                 LSR     A
00:F65A  4A                :                 LSR     A
00:F65B  205FF6            :                 JSR     HEX             ; Convert and display
00:F65E  68                :                 PLA                     ; Pull back value and ...
                             
                             ; Display the lo nybble of A as a hexadecimal digit. The values in A & Y are
                             ; destroyed.
                             
00:F65F  2065F6            : HEX             JSR     TO_HEX          ; Convert to printable character
00:F662  4C1EFF            :                 JMP     UART_TX         ; And display.
                                             
                             ;
                                             
00:F665  290F              : TO_HEX          AND     #$0F            ; Isolate the lo nybble

Portable 65xx Assembler [16.06]

00:F667  F8                :                 SED                     ; Converted to ASCII
00:F668  18                :                 CLC
00:F669  6990              :                 ADC     #$90
00:F66B  6940              :                 ADC     #$40
00:F66D  D8                :                 CLD
00:F66E  60                :                 RTS
                             
                             ; Output two spaces.
                             
                             SPACE2:
00:F66F  2072F6            :                 JSR     SPACE
                                             
                             ; Output a single space. The values in A & Y are destroyed.
                             
                             SPACE:
00:F672  A920              :                 LDA     #' '
00:F674  4C1EFF            :                 JMP     UART_TX
                                             
                             BAR:
00:F677  A97C              :                 LDA     #'|'
00:F679  4C1EFF            :                 JMP     UART_TX
                             
                             ; Output a CR/LF control sequence to move the display cursor to the start of
                             ; the next line. A & Y are destroyed.
                             
                             CRLF:
00:F67C  A90D              :                 LDA     #CR             ; Output a carriage return
00:F67E  201EFF            :                 JSR     UART_TX
00:F681  A90A              :                 LDA     #LF             ; .. followed by a new line
00:F683  4C1EFF            :                 JMP     UART_TX
                             
                             ;-------------------------------------------------------------------------------
                             
                             
                             SHOW_STR:
                                             REPEAT
00:F686  BD92F6            :                  LDA    STRINGS,X
00:F689  D001              :                  IF     EQ
00:F68B  60                :                   RTS
                                              ENDIF
00:F68C  201EFF            :                  JSR    UART_TX
00:F68F  E8                :                  INX
00:F690  80F4              :                 FOREVER
                             
                             STRINGS:
         00000000          = PC_STR          .EQU    .-STRINGS
00:F692  50433D00          :                 .BYTE   "PC=",0
         00000004          = SP_STR          .EQU    .-STRINGS
00:F696  2053503D00        :                 .BYTE   " SP=",0
         00000009          = P_STR           .EQU    .-STRINGS
00:F69B  20503D00          :                 .BYTE   " P=",0
         0000000D          = A_STR           .EQU    .-STRINGS
00:F69F  20413D00          :                 .BYTE   " A=",0
         00000011          = X_STR           .EQU    .-STRINGS

Portable 65xx Assembler [16.06]

00:F6A3  20583D00          :                 .BYTE   " X=",0
         00000015          = Y_STR           .EQU    .-STRINGS
00:F6A7  20593D00          :                 .BYTE   " Y=",0
         00000019          = ERR_STR         .EQU    .-STRINGS
00:F6AB  0D0A3F00          :                 .BYTE   CR,LF,"?",0
         0000001D          = HLP_STR         .EQU    .-STRINGS
00:F6AF  0D0A412078787878> :                 .BYTE   CR,LF,"A xxxx opcode [args]\tAssemble"
00:F6CE  0D0A442078787878> :                 .BYTE   CR,LF,"D xxxx yyyy\t\tDisassemble"
00:F6E8  0D0A47205B787878> :                 .BYTE   CR,LF,"G [xxxx]\t\tGoto"
00:F6F8  0D0A4D2078787878> :                 .BYTE   CR,LF,"M xxxx yyyy\t\tDisplay Memory"
00:F715  0D0A520909094469> :                 .BYTE   CR,LF,"R\t\t\tDisplay Registers"
00:F72C  0D0A532E2E2E0909> :                 .BYTE   CR,LF,"S...\t\t\tS19 Load"
00:F73D  0D0A54205B787878> :                 .BYTE   CR,LF,"T [xxxx]\t\tTrace"
00:F74E  0D0A572078787878> :                 .BYTE   CR,LF,"W xxxx yy\t\tWrite Memory"
00:F767  00                :                 .BYTE   0
                                             
00:F768  435A49443131564E  : FLAG            .BYTE   "CZID11VN"
00:F770  0102040810204080  : BITS            .BYTE   $01,$02,$04,$08,$10,$20,$40,$80
                                             
                             ;==============================================================================
                             ; I/O Page
                             ;-------------------------------------------------------------------------------
                             
                                             .ORG    $FE00
00:FE00  0000000000000000> :                 .SPACE  256
                             
                             ;===============================================================================
                             ; Reset Handler
                             ;-------------------------------------------------------------------------------
                             
                                             .ORG    $FF00
                             
                             RESET:
00:FF00  D8                :                 CLD                     ; Ensure binary mode
00:FF01  A2FF              :                 LDX     #$FF            ; Reset the stack
00:FF03  9A                :                 TXS
                             
00:FF04  E8                :                 INX                     ; Clear buffer offsets
00:FF05  8E0002            :                 STX     RX_HEAD
00:FF08  8E0102            :                 STX     RX_TAIL
00:FF0B  8E0202            :                 STX     TX_HEAD
00:FF0E  8E0302            :                 STX     TX_TAIL
                             ;               STX     FLAGS           ; And flow control flags
                             
00:FF11  A901              :                 LDA     #$01            ; Enable ACIA RX interrupt
00:FF13  8D02FE            :                 STA     ACIA_CMND
                             
00:FF16  58                :                 CLI                     ; Allow interrupts
00:FF17  00                :                 BRK
                             
                             ;===============================================================================
                             ; UART Interface
                             ;-------------------------------------------------------------------------------
                             

Portable 65xx Assembler [16.06]

                             XON:
00:FF18  A911              :                 LDA     #DC1
00:FF1A  D002              :                 BNE     UART_TX
                             
                             XOFF:
00:FF1C  A913              :                 LDA     #DC3
                             
                             ; Inserts the byte in A into the transmit buffer. If the buffer is full then
                             ; wait until some space is available. Registers are preserved.
                             
                             UART_TX:
00:FF1E  48                :                 PHA
00:FF1F  84FE              :                 STY     IO_TEMP
                                             
00:FF21  AC0302            :                 LDY     TX_TAIL         ; Save the data byte at the tail
00:FF24  994202            :                 STA     TX_BUFF,Y
00:FF27  20A1FF            :                 JSR     BUMP_TX         ; Work out the next offset
                                             REPEAT                  ; And wait until save to store
00:FF2A  CC0202            :                  CPY    TX_HEAD
00:FF2D  F0FB              :                 UNTIL   NE
00:FF2F  8C0302            :                 STY     TX_TAIL
00:FF32  A905              :                 LDA     #$05            ; Ensure TX interrupt enabled
00:FF34  8D02FE            :                 STA     ACIA_CMND
                                             
00:FF37  A4FE              :                 LDY     IO_TEMP
00:FF39  68                :                 PLA
00:FF3A  60                :                 RTS                     ; Done
                             
                             ;
                             ;
                             
                             UART_RX:
                             ;               BIT     FLAGS           ; Terminal stopped from sending?
                             ;               IF      MI
                             ;                JSR    RX_COUNT        ; Yes, check RX buffer count
                             ;                CMP    #RX_SIZE*1/10   ; Restart when only 10% full
                             ;                IF     CC
                             ;                 LDA   #DC1            ; Send XON
                             ;                 JSR   UART_TX
                             ;               .IF     __65C02__
                             ;                 STZ   FLAGS           ; Mark as no longer stopped
                             ;               .ELSE
                             ;                 LDA   #0              ; Mark as no longer stopped
                             ;                 STA   FLAGS
                             ;               .ENDIF
                             ;                ENDIF
                             ;               ENDIF
                             
00:FF3B  84FE              :                 STY     IO_TEMP
00:FF3D  AC0002            :                 LDY     RX_HEAD         ; Wait until there is some data
                                             REPEAT
00:FF40  CC0102            :                  CPY    RX_TAIL
00:FF43  F0FB              :                 UNTIL   NE
00:FF45  B90402            :                 LDA     RX_BUFF,Y       ; Then extract the head byte

Portable 65xx Assembler [16.06]

00:FF48  20A1FF            :                 JSR     BUMP_RX         ; Update the offset
00:FF4B  8C0002            :                 STY     RX_HEAD
00:FF4E  A4FE              :                 LDY     IO_TEMP
00:FF50  60                :                 RTS                     ; Done
                             
                             ;
                             ;
                             
                                             .IF     0
                           - RX_COUNT:
                           -                 SEC
                           -                 LDA     RX_TAIL         ; Subtract the two offsets
                           -                 SBC     RX_HEAD
                           -                 IF      CC
                           -                  ADC    #RX_SIZE        ; And correct if negative
                           -                 ENDIF
                           -                 RTS                     ; Done
                                             .ENDIF
                                             
                             ;===============================================================================
                             ; NMI Handler
                             ;-------------------------------------------------------------------------------
                             
                             NMI:
00:FF51  4C8EF2            :                 JMP     BREAK
                             
                             ;===============================================================================
                             ; IRQ Handler
                             ;-------------------------------------------------------------------------------
                             
                             ; Handle interrupts, currently just UART transmit buffer empty and recieve
                             ; buffer full.
                             
                             IRQ:
00:FF54  48                :                 PHA                     ; Save users registers
                                             .IF     __65C02__
00:FF55  DA                :                 PHX
00:FF56  5A                :                 PHY
                                             .ELSE
                           -                 TXA
                           -                 PHA
                           -                 TYA
                           -                 PHA
                           -                 CLD
                                             .ENDIF
                             
00:FF57  BA                :                 TSX                     ; Check for BRK
00:FF58  BD0401            :                 LDA     STACK+4,X
00:FF5B  2910              :                 AND     #$10
00:FF5D  D0F2              :                 BNE     NMI             ; Enter via NMI handler
                             
                             ;-------------------------------------------------------------------------------
                             
00:FF5F  AD01FE            :                 LDA     ACIA_STAT       ; ACIA is the source?

Portable 65xx Assembler [16.06]

00:FF62  1039              :                 BPL     NOT_ACIA        ; No.
                             
00:FF64  48                :                 PHA
00:FF65  2910              :                 AND     #$10            ; TX Buffer empty?
00:FF67  F01B              :                 IF      NE
                             ;                BIT    FLAGS           ; Do we need to send XOFF?
                             ;                IF     VS
                             ;                 LDA   #DC3            ; Yes, send XOFF to terminal
                             ;                 STA   ACIA_DATA
                             ;                 ASL   FLAGS           ; And mark as sent
                             ;                 BNE   NOT_ACIA
                             ;                ENDIF
                             
00:FF69  AC0202            :                  LDY    TX_HEAD         ; Any data to send?
00:FF6C  CC0302            :                  CPY    TX_TAIL
00:FF6F  F00E              :                  IF     NE
00:FF71  B94202            :                   LDA   TX_BUFF,Y       ; Yes, extract and send it
00:FF74  8D00FE            :                   STA   ACIA_DATA
00:FF77  20A1FF            :                   JSR   BUMP_TX
00:FF7A  8C0202            :                   STY   TX_HEAD
00:FF7D  8005              :                  ELSE
00:FF7F  A901              :                   LDA   #$01            ; No, disable TX interrupt
00:FF81  8D02FE            :                   STA   ACIA_CMND
                                              ENDIF
                                             ENDIF
                             
00:FF84  68                :                 PLA
00:FF85  2908              :                 AND     #$08            ; RX Buffer full?
00:FF87  F014              :                 IF      NE
00:FF89  AD00FE            :                  LDA    ACIA_DATA       ; Yes, fetch the character
00:FF8C  AC0102            :                  LDY    RX_TAIL         ; .. and save it
00:FF8F  990402            :                  STA    RX_BUFF,Y
00:FF92  20A1FF            :                  JSR    BUMP_RX
00:FF95  CC0002            :                  CPY    RX_HEAD         ; Is buffer completely full?
00:FF98  F003              :                  IF     NE
00:FF9A  8C0102            :                   STY   RX_TAIL         ; No, update tail offset
                                              ENDIF
                             
                             ;                BIT    FLAGS           ; Already stopped or stopping?
                             ;                IF     PL
                             ;                 IF    VC
                             ;                  JSR  RX_COUNT        ; Fetch FX buffer count
                             ;                  CMP  #RX_SIZE*9/10   ; More than 90%
                             ;                  IF   CS
                             ;                   LDA #FLAG_STOP      ; Yes, set flags to send XOFF
                             ;                   STA FLAGS
                             ;                   LDA #$05            ; Ensure transmit interrupt enabled
                             ;                   STA ACIA_CMND
                             ;                  ENDIF
                             ;                 ENDIF
                             ;                ENDIF
                                             ENDIF
                             NOT_ACIA:
                             

Portable 65xx Assembler [16.06]

                             ;-------------------------------------------------------------------------------
                             
                                             .IF     __65C02__
00:FF9D  7A                :                 PLY                     ; Restore user registers
00:FF9E  FA                :                 PLX
                                             .ELSE
                           -                 PLA                     ; Restore user registers
                           -                 TAY
                           -                 PLA
                           -                 TAX
                                             .ENDIF
00:FF9F  68                :                 PLA
00:FFA0  40                :                 RTI                     ; Done
                             
                             ; Bump and wrap a recieve buffer index value.
                             
                             BUMP_RX:
                                             .IF     RX_SIZE != TX_SIZE
                           -                 INY
                           -                 CPY     #RX_SIZE
                           -                 IF      EQ
                           -                  LDY    #0
                           -                 ENDIF
                           -                 RTS
                                             .ENDIF
                             
                             ; Bump and wrap a transmit buffer index value.
                             
                             BUMP_TX:
00:FFA1  C8                :                 INY
00:FFA2  C03E              :                 CPY     #TX_SIZE
00:FFA4  D002              :                 IF      EQ
00:FFA6  A000              :                  LDY    #0
                                             ENDIF
00:FFA8  60                :                 RTS
                             
                             ;===============================================================================
                             ; Vector Locations
                             ;-------------------------------------------------------------------------------
                             
                                             .ORG    $FFFA
                             
00:FFFA  51FF              :                 .WORD   NMI             ; NMI
00:FFFC  00FF              :                 .WORD   RESET           ; RESET
00:FFFE  54FF              :                 .WORD   IRQ             ; IRQ/BRK
                             
                                             .END


Portable 65xx Assembler [16.06]

Symbol Table

ACIA_CMND                        0000FE02  | MB_IMP                           00000000 
ACIA_CTRL                        0000FE03  | MO_IMP                           00000000 
ACIA_DATA                        0000FE00  | NUL                              00000000 
ACIA_STAT                        0000FE01  | OP_ERR                           00000000 
ADDR_E                           000000F9  | PC_STR                           00000000 
ADDR_S                           000000F7  | __6501__                         00000000 
APPEND_CHAR                      0000F4AB  | __6502__                         00000000 
APPEND_HEX                       0000F4A8  | __65816__                        00000000 
APPEND_HEX2                      0000F49F  | __65832__                        00000000 
A_REG                            000000F0  | __65SC02__                       00000000 
A_STR                            0000000D  | MB_ZPG                           00000001 
BACKSPACE                        0000F323  | MO_ZPG                           00000001 
BAR                              0000F677  | __65C02__                        00000001 
BEL                              00000007  | MB_IMM                           00000002 
BITS                             0000F770  | MO_IMM                           00000002 
BREAK                            0000F28E  | OP_ADC                           00000002 
BS                               00000008  | MB_ABS                           00000003 
BUFFER                           00000280  | MO_ABS                           00000003 
BUMP_ADDR                        0000F46F  | MB_YRG                           00000004 
BUMP_RX                          0000FFA1  | OP_AND                           00000004 
BUMP_TX                          0000FFA1  | SP_STR                           00000004 
CHECK_END                        0000F479  | MO_ZPX                           00000005 
CMD_LEN                          000000F6  | MO_ZPY                           00000005 
CMD_SIZE                         00000080  | OP_ASL                           00000006 
COMMAND                          0000F2FA  | BEL                              00000007 
COUNT                            000000FD  | MO_ABY                           00000007 
CR                               0000000D  | BS                               00000008 
CRLF                             0000F67C  | MB_XRG                           00000008 
DC1                              00000011  | OP_BBR                           00000008 
DC3                              00000013  | HT                               00000009 
DEL                              0000007F  | P_STR                            00000009 
DISASSEMBLE                      0000F537  | LF                               0000000A 
ERROR                            0000F455  | OP_BBS                           0000000A 
ERR_STR                          00000019  | MO_ABX                           0000000B 
ESC                              0000001B  | OP_BCC                           0000000C 
EXTRACT_LETTER                   0000F63D  | A_STR                            0000000D 
FLAG                             0000F768  | CR                               0000000D 
FLAGS                            000000FF  | OP_BCS                           0000000E 
FLAG_STOP                        00000040  | MB_ACC                           00000010 
FLAG_STOPPED                     00000080  | MO_ACC                           00000010 
GET_BYTE                         0000F4D7  | OP_BEQ                           00000010 
GET_NYBBLE                       0000F50A  | DC1                              00000011 
GET_WORD                         0000F4D3  | X_STR                            00000011 
HEX                              0000F65F  | OP_BIT                           00000012 
HEX2                             0000F656  | DC3                              00000013 
HLP_STR                          0000001D  | OP_BNE                           00000014 
HT                               00000009  | Y_STR                            00000015 
IO_TEMP                          000000FE  | OP_BMI                           00000016 
IRQ                              0000FF54  | OP_BPL                           00000018 
IS_HEX                           0000F51B  | ERR_STR                          00000019 
IS_PRINTABLE                     0000F52B  | OP_BRA                           0000001A 
LF                               0000000A  | ESC                              0000001B 

Portable 65xx Assembler [16.06]

MB_ABS                           00000003  | OP_BRK                           0000001C 
MB_ACC                           00000010  | HLP_STR                          0000001D 
MB_BIT                           00000020  | OP_BVC                           0000001E 
MB_IMM                           00000002  | MB_BIT                           00000020 
MB_IMP                           00000000  | OP_BVS                           00000020 
MB_IND                           00000080  | MO_BIT                           00000021 
MB_REL                           00000040  | OP_CLC                           00000022 
MB_XRG                           00000008  | OP_CLD                           00000024 
MB_YRG                           00000004  | OP_CLI                           00000026 
MB_ZPG                           00000001  | OP_CLV                           00000028 
MNEMONICS                        0000F200  | OP_CMP                           0000002A 
MODES                            0000F100  | OP_CPX                           0000002C 
MO_ABS                           00000003  | OP_CPY                           0000002E 
MO_ABX                           0000000B  | OP_DEC                           00000030 
MO_ABY                           00000007  | OP_DEX                           00000032 
MO_ACC                           00000010  | OP_DEY                           00000034 
MO_BIT                           00000021  | OP_EOR                           00000036 
MO_BRL                           00000061  | OP_INC                           00000038 
MO_IAB                           00000083  | OP_INX                           0000003A 
MO_IAX                           0000008B  | OP_INY                           0000003C 
MO_IMM                           00000002  | OP_JMP                           0000003E 
MO_IMP                           00000000  | RX_SIZE                          0000003E 
MO_IZP                           00000081  | TX_SIZE                          0000003E 
MO_IZX                           00000089  | FLAG_STOP                        00000040 
MO_IZY                           00000085  | MB_REL                           00000040 
MO_REL                           00000040  | MO_REL                           00000040 
MO_ZPG                           00000001  | OP_JSR                           00000040 
MO_ZPX                           00000005  | OP_LDA                           00000042 
MO_ZPY                           00000005  | OP_LDX                           00000044 
NEXT_CHAR                        0000F4B2  | OP_LDY                           00000046 
NMI                              0000FF51  | OP_LSR                           00000048 
NOT_ACIA                         0000FF9D  | OP_NOP                           0000004A 
NUL                              00000000  | OP_ORA                           0000004C 
OPCODES                          0000F000  | OP_PHA                           0000004E 
OP_ADC                           00000002  | OP_PHP                           00000050 
OP_AND                           00000004  | OP_PHX                           00000052 
OP_ASL                           00000006  | OP_PHY                           00000054 
OP_BBR                           00000008  | OP_PLA                           00000056 
OP_BBS                           0000000A  | OP_PLP                           00000058 
OP_BCC                           0000000C  | OP_PLX                           0000005A 
OP_BCS                           0000000E  | OP_PLY                           0000005C 
OP_BEQ                           00000010  | OP_RMB                           0000005E 
OP_BIT                           00000012  | OP_ROL                           00000060 
OP_BMI                           00000016  | MO_BRL                           00000061 
OP_BNE                           00000014  | OP_ROR                           00000062 
OP_BPL                           00000018  | OP_RTI                           00000064 
OP_BRA                           0000001A  | OP_RTS                           00000066 
OP_BRK                           0000001C  | OP_SBC                           00000068 
OP_BVC                           0000001E  | OP_SEC                           0000006A 
OP_BVS                           00000020  | OP_SED                           0000006C 
OP_CLC                           00000022  | OP_SEI                           0000006E 
OP_CLD                           00000024  | OP_SMB                           00000070 
OP_CLI                           00000026  | OP_STA                           00000072 
OP_CLV                           00000028  | OP_STP                           00000074 

Portable 65xx Assembler [16.06]

OP_CMP                           0000002A  | OP_STX                           00000076 
OP_CPX                           0000002C  | OP_STY                           00000078 
OP_CPY                           0000002E  | OP_STZ                           0000007A 
OP_DEC                           00000030  | OP_TAX                           0000007C 
OP_DEX                           00000032  | OP_TAY                           0000007E 
OP_DEY                           00000034  | DEL                              0000007F 
OP_EOR                           00000036  | CMD_SIZE                         00000080 
OP_ERR                           00000000  | FLAG_STOPPED                     00000080 
OP_INC                           00000038  | MB_IND                           00000080 
OP_INX                           0000003A  | OP_TRB                           00000080 
OP_INY                           0000003C  | MO_IZP                           00000081 
OP_JMP                           0000003E  | OP_TSB                           00000082 
OP_JSR                           00000040  | MO_IAB                           00000083 
OP_LDA                           00000042  | OP_TSX                           00000084 
OP_LDX                           00000044  | MO_IZY                           00000085 
OP_LDY                           00000046  | OP_TXA                           00000086 
OP_LSR                           00000048  | OP_TXS                           00000088 
OP_NOP                           0000004A  | MO_IZX                           00000089 
OP_ORA                           0000004C  | OP_TYA                           0000008A 
OP_PHA                           0000004E  | MO_IAX                           0000008B 
OP_PHP                           00000050  | OP_WAI                           0000008C 
OP_PHX                           00000052  | A_REG                            000000F0 
OP_PHY                           00000054  | X_REG                            000000F1 
OP_PLA                           00000056  | Y_REG                            000000F2 
OP_PLP                           00000058  | P_REG                            000000F3 
OP_PLX                           0000005A  | PC_REG                           000000F4 
OP_PLY                           0000005C  | CMD_LEN                          000000F6 
OP_RMB                           0000005E  | ADDR_S                           000000F7 
OP_ROL                           00000060  | ADDR_E                           000000F9 
OP_ROR                           00000062  | TEMP                             000000FB 
OP_RTI                           00000064  | COUNT                            000000FD 
OP_RTS                           00000066  | IO_TEMP                          000000FE 
OP_SBC                           00000068  | FLAGS                            000000FF 
OP_SEC                           0000006A  | STACK                            00000100 
OP_SED                           0000006C  | RX_HEAD                          00000200 
OP_SEI                           0000006E  | RX_TAIL                          00000201 
OP_SMB                           00000070  | TX_HEAD                          00000202 
OP_STA                           00000072  | TX_TAIL                          00000203 
OP_STP                           00000074  | RX_BUFF                          00000204 
OP_STX                           00000076  | TX_BUFF                          00000242 
OP_STY                           00000078  | BUFFER                           00000280 
OP_STZ                           0000007A  | OPCODES                          0000F000 
OP_TAX                           0000007C  | MODES                            0000F100 
OP_TAY                           0000007E  | MNEMONICS                        0000F200 
OP_TRB                           00000080  | BREAK                            0000F28E 
OP_TSB                           00000082  | REGISTERS                        0000F2A6 
OP_TSX                           00000084  | COMMAND                          0000F2FA 
OP_TXA                           00000086  | PROMPT                           0000F2FC 
OP_TXS                           00000088  | BACKSPACE                        0000F323 
OP_TYA                           0000008A  | SQUAWK                           0000F343 
OP_WAI                           0000008C  | ERROR                            0000F455 
PC_REG                           000000F4  | SET_ADDR_S                       0000F45D 
PC_STR                           00000000  | SET_ADDR_E                       0000F466 
PROMPT                           0000F2FC  | BUMP_ADDR                        0000F46F 

Portable 65xx Assembler [16.06]

P_REG                            000000F3  | CHECK_END                        0000F479 
P_STR                            00000009  | SET_PROMPT                       0000F483 
REGISTERS                        0000F2A6  | APPEND_HEX2                      0000F49F 
RESET                            0000FF00  | APPEND_HEX                       0000F4A8 
RX_BUFF                          00000204  | APPEND_CHAR                      0000F4AB 
RX_HEAD                          00000200  | NEXT_CHAR                        0000F4B2 
RX_SIZE                          0000003E  | TO_UPPER                         0000F4BB 
RX_TAIL                          00000201  | SKIP_CHAR                        0000F4C7 
SET_ADDR_E                       0000F466  | GET_WORD                         0000F4D3 
SET_ADDR_S                       0000F45D  | GET_BYTE                         0000F4D7 
SET_PROMPT                       0000F483  | GET_NYBBLE                       0000F50A 
SHOW_STR                         0000F686  | IS_HEX                           0000F51B 
SKIP_CHAR                        0000F4C7  | IS_PRINTABLE                     0000F52B 
SPACE                            0000F672  | DISASSEMBLE                      0000F537 
SPACE2                           0000F66F  | EXTRACT_LETTER                   0000F63D 
SPI_CTRL                         0000FE05  | HEX2                             0000F656 
SPI_DATA                         0000FE04  | HEX                              0000F65F 
SPI_DVSR                         0000FE06  | TO_HEX                           0000F665 
SPI_SLCT                         0000FE07  | SPACE2                           0000F66F 
SPI_STAT                         0000FE05  | SPACE                            0000F672 
SP_STR                           00000004  | BAR                              0000F677 
SQUAWK                           0000F343  | CRLF                             0000F67C 
STACK                            00000100  | SHOW_STR                         0000F686 
STRINGS                          0000F692  | STRINGS                          0000F692 
TEMP                             000000FB  | FLAG                             0000F768 
TO_HEX                           0000F665  | BITS                             0000F770 
TO_UPPER                         0000F4BB  | ACIA_DATA                        0000FE00 
TX_BUFF                          00000242  | ACIA_STAT                        0000FE01 
TX_HEAD                          00000202  | ACIA_CMND                        0000FE02 
TX_SIZE                          0000003E  | ACIA_CTRL                        0000FE03 
TX_TAIL                          00000203  | SPI_DATA                         0000FE04 
UART_RX                          0000FF3B  | SPI_CTRL                         0000FE05 
UART_TX                          0000FF1E  | SPI_STAT                         0000FE05 
XOFF                             0000FF1C  | SPI_DVSR                         0000FE06 
XON                              0000FF18  | SPI_SLCT                         0000FE07 
X_REG                            000000F1  | RESET                            0000FF00 
X_STR                            00000011  | XON                              0000FF18 
Y_REG                            000000F2  | XOFF                             0000FF1C 
Y_STR                            00000015  | UART_TX                          0000FF1E 
__6501__                         00000000  | UART_RX                          0000FF3B 
__6502__                         00000000  | NMI                              0000FF51 
__65816__                        00000000  | IRQ                              0000FF54 
__65832__                        00000000  | NOT_ACIA                         0000FF9D 
__65C02__                        00000001  | BUMP_RX                          0000FFA1 
__65SC02__                       00000000  | BUMP_TX                          0000FFA1 
