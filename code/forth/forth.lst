
Portable 65xx Assembler [16.06]

                             ;
                             
                             ;
                             
                                             .6502
                             
                                             .include "../sb-6502.inc"
                             ;===============================================================================
                             ; Hardware Definitions
                             ;-------------------------------------------------------------------------------
                             
         00000100          = STACK           .equ    $0100
                             
                             ; Emulated 6551 ACIA
                             
         0000FE00          = ACIA_DATA       .equ    $fe00           ; R/W
         0000FE01          = ACIA_STAT       .equ    $fe01           ; R/W
         0000FE02          = ACIA_CMND       .equ    $fe02           ; R/W
         0000FE03          = ACIA_CTRL       .equ    $fe03           ; R/W
                             
                             ; Emulated 65SPI
                             
         0000FE10          = SPI_DATA        .equ    $fe10           ; R/W
         0000FE11          = SPI_STAT        .equ    $fe11           ; R/O
         0000FE11          = SPI_CTRL        .equ    $fe11           ; W/O
         0000FE12          = SPI_DVSR        .equ    $fe12           ; R/W
         0000FE13          = SPI_SLCT        .equ    $fe13           ; R/W
                             
                             ; Emulated DS1318 RTCC
                             
         0000FE20          = RTC_SUB0        .equ    $fe20           ; R/W
         0000FE21          = RTC_SUB1        .equ    $fe21           ; R/W
         0000FE22          = RTC_SEC0        .equ    $fe22           ; R/W
         0000FE23          = RTC_SEC1        .equ    $fe23           ; R/W
         0000FE24          = RTC_SEC2        .equ    $fe24           ; R/W
         0000FE25          = RTC_SEC3        .equ    $fe25           ; R/W
         0000FE26          = RTC_ALM0        .equ    $fe26           ; R/W
         0000FE27          = RTC_ALM1        .equ    $fe27           ; R/W
         0000FE27          = RTC_ALM2        .equ    $fe27           ; R/W
         0000FE28          = RTC_ALM3        .equ    $fe28           ; R/W
         0000FE2A          = RTC_CTLA        .equ    $fe2a           ; R/W
         0000FE2B          = RTC_CTLB        .equ    $fe2b           ; R/W
         0000FE2C          = RTC_STAT        .equ    $fe2c           ; R/W
                             
                             ;===============================================================================
                             ; ASCII Control Characters
                             ;-------------------------------------------------------------------------------
                             
         00000000          = NUL             .equ    $00
         00000007          = BEL             .equ    $07
         00000008          = BS              .equ    $08
         00000009          = HT              .equ    $09
         0000000D          = CR              .equ    $0d
         0000000A          = LF              .equ    $0a

Portable 65xx Assembler [16.06]

         00000011          = DC1             .equ    $11                     ; XON
         00000013          = DC3             .equ    $13                     ; XOFF
         0000001B          = ESC             .equ    $1b
         0000007F          = DEL             .equ    $7f
                             
                             ;===============================================================================
                             ;-------------------------------------------------------------------------------
                             
         00000040          = RX_SIZE         .equ    64
         00000040          = TX_SIZE         .equ    64
                             
         00000000          = DSTACK          .equ    $0000
         00000100          = RSTACK          .equ    $0100
                             
                             
                             ;===============================================================================
                             ; Data Areas
                             ;-------------------------------------------------------------------------------
                             
                                             .page0
                                             .org    $00d0
                             
                             
                             
                             ;-------------------------------------------------------------------------------
                             
                                             .org    $00f0
                             
                             ; Communications buffer offsets
                             
00:00F0  00                : RX_HEAD         .space  1               ; UART receive buffer offsets
00:00F1  00                : RX_TAIL         .space  1
00:00F2  00                : TX_HEAD         .space  1               ; UART transmit buffer offsets
00:00F3  00                : TX_TAIL         .space  1
                             
                             
                             ;-------------------------------------------------------------------------------
                             
                                             .org    $00ff
                             
00:00FF  00                : IO_TEMP         .space  1               ;
                             
                             ;-------------------------------------------------------------------------------
                             
                             
                             ;===============================================================================
                             ; Data Areas
                             ;-------------------------------------------------------------------------------
                             
                                             .bss
                             
                                             .org    $e000
                             
                             

Portable 65xx Assembler [16.06]

                             ;-------------------------------------------------------------------------------
                             ; UART Buffers
                             
                                             .org    $ef00
                             
00:EF00  0000000000000000> : RX_BUFF         .space  RX_SIZE         ; UART receive buffer
00:EF40  0000000000000000> : TX_BUFF         .space  TX_SIZE         ; UART transmit buffer
                             
                             ;===============================================================================
                             ; Macros
                             ;-------------------------------------------------------------------------------
                             
                             ; The LINK macro deposits the link section of a word header automatically
                             ; linking the new word to the last.
                             
         00000000          = LASTWORD        .set    0                       ; Word counter
                             
                             LINK            .macro  TYPE
                                             .word   LASTWORD                ; Link
                                             .byte   TYPE                    ; Type
                             LASTWORD        .set    $
                                             .endm
                             
                             ; Deposits a word header containing the name which is linked back to the
                             ; previous word.
                             ;
                             ; The WDC assembler does not handle string parameters to macros very well,
                             ; stopping at the first comma or space in them, so some headers must be
                             ; manually constructed.
                             
         00000000          = NORMAL          .equ    $00
         00000080          = IMMEDIATE       .equ    $80
         00000040          = INLINE          .equ    $40
                             
                             HEADER          .macro  LEN,NAME,TYPE
                                             LINK    TYPE
                                             .byte   LEN,NAME
                                             .endm
                             
                             ;===============================================================================
                             ; Reset Handler
                             ;-------------------------------------------------------------------------------
                             
                                             .code
                                             .org    $F000
                             
                             RESET:
00:F000  78                :                 sei                     ; Ensure interrupts disabled
00:F001  D8                :                 cld                     ; Ensure binary mode
00:F002  A2FF              :                 ldx     #$ff            ; Reset the stack
00:F004  9A                :                 txs
                             
00:F005  E8                :                 inx
00:F006  86F0              :                 stx     RX_HEAD         ; Clear buffer offsets

Portable 65xx Assembler [16.06]

00:F008  86F1              :                 stx     RX_TAIL
00:F00A  86F2              :                 stx     TX_HEAD
00:F00C  86F3              :                 stx     TX_TAIL
                             
00:F00E  A91F              :                 lda     #%00011111      ; 8 bits, 1 stop bit, 19200 baud
00:F010  8D03FE            :                 sta     ACIA_CTRL
00:F013  A9C9              :                 lda     #%11001001      ; No parity, no interrupt
00:F015  8D02FE            :                 sta     ACIA_CMND
00:F018  AD00FE            :                 lda     ACIA_DATA       ; Clear receive buffer
                             
                             ;===============================================================================
                             ; System/User Variables
                             ;-------------------------------------------------------------------------------
                             
                             ;===============================================================================
                             ; Constants
                             ;-------------------------------------------------------------------------------
                             
                             ; 0 ( -- 0 )
                             ;
                             ; Push the constant value zero on the stack
                             
                                             HEADER  1,"0",NORMAL
                           +                 LINK    NORMAL
00:F01B  0000              +                 .word   LASTWORD                ; Link
00:F01D  00                +                 .byte   NORMAL                  ; Type
         0000F01E          = LASTWORD        .set    $
00:F01E  0130              +                 .byte   1,"0"
                             ZERO:
00:F020  CA                :                 dex                     ; Make space on the stack
00:F021  CA                :                 dex
00:F022  A900              :                 lda     #$00            ; And create a zero value
00:F024  9501              :                 sta     DSTACK+1,x
00:F026  9502              :                 sta     DSTACK+2,x
00:F028  60                :                 rts                     ; Done
                             
                             ; BL ( -- char )
                             ;
                             ; char is the character value for a space.
                             
                                             HEADER  2,"BL",NORMAL
                           +                 LINK    NORMAL
00:F029  1EF0              +                 .word   LASTWORD                ; Link
00:F02B  00                +                 .byte   NORMAL                  ; Type
         0000F02C          = LASTWORD        .set    $
00:F02C  02424C            +                 .byte   2,"BL"
                             BL:
00:F02F  CA                :                 dex                     ; Make space on the stack
00:F030  CA                :                 dex
00:F031  A920              :                 lda     #' '            ; And save a space value
00:F033  9501              :                 sta     DSTACK+1,x
00:F035  A900              :                 lda     #0
00:F037  9502              :                 sta     DSTACK+2,x
00:F039  60                :                 rts                     ; Done

Portable 65xx Assembler [16.06]

                             
                             ; FALSE ( -- false )
                             ;
                             ; Return a false flag.
                             
                                             HEADER  5,"FALSE",NORMAL
                           +                 LINK    NORMAL
00:F03A  2CF0              +                 .word   LASTWORD                ; Link
00:F03C  00                +                 .byte   NORMAL                  ; Type
         0000F03D          = LASTWORD        .set    $
00:F03D  0546414C5345      +                 .byte   5,"FALSE"
                             FALSE:
00:F043  CA                :                 dex                     ; Make space on the stack
00:F044  CA                :                 dex
00:F045  A900              :                 lda     #$00            ; And create a false value
00:F047  9501              :                 sta     DSTACK+1,x
00:F049  9502              :                 sta     DSTACK+2,x
00:F04B  60                :                 rts                     ; Done
                             
                             ; TRUE ( -- true )
                             ;
                             ; Return a true flag, a single-cell value with all bits set.
                             
                                             HEADER  4,"TRUE",NORMAL
                           +                 LINK    NORMAL
00:F04C  3DF0              +                 .word   LASTWORD                ; Link
00:F04E  00                +                 .byte   NORMAL                  ; Type
         0000F04F          = LASTWORD        .set    $
00:F04F  0454525545        +                 .byte   4,"TRUE"
                             TRUE:
00:F054  CA                :                 dex                     ; Make space on the stack
00:F055  CA                :                 dex
00:F056  A9FF              :                 lda     #$ff            ; And create a true value
00:F058  9501              :                 sta     DSTACK+1,x
00:F05A  9502              :                 sta     DSTACK+2,x
00:F05C  60                :                 rts                     ; Done
                             
                             ;===============================================================================
                             ; Radix
                             ;-------------------------------------------------------------------------------
                             
                             ; DECIMAL ( -- )
                             ;
                             ; Set the numeric conversion radix to ten (decimal).
                             
                                             HEADER  7,"DECIMAL",NORMAL
                           +                 LINK    NORMAL
00:F05D  4FF0              +                 .word   LASTWORD                ; Link
00:F05F  00                +                 .byte   NORMAL                  ; Type
         0000F060          = LASTWORD        .set    $
00:F060  07444543494D414C  +                 .byte   7,"DECIMAL"
                             DECIMAL:
Error: forth.asm (208) Undefined symbol: DO_LITERAL
00:F068  200000            :                 jsr     DO_LITERAL

Portable 65xx Assembler [16.06]

00:F06B  0A00              :                 .word   10
Error: forth.asm (210) Undefined symbol: BASE
00:F06D  200000            :                 jsr     BASE
00:F070  4C8AF0            :                 jmp     STORE
                             
                             ; HEX ( -- )
                             ;
                             ; Set contents of BASE to sixteen.
                             
                                             HEADER  3,"HEX",NORMAL
                           +                 LINK    NORMAL
00:F073  60F0              +                 .word   LASTWORD                ; Link
00:F075  00                +                 .byte   NORMAL                  ; Type
         0000F076          = LASTWORD        .set    $
00:F076  03484558          +                 .byte   3,"HEX"
                             HEX:
Error: forth.asm (219) Undefined symbol: DO_LITERAL
00:F07A  200000            :                 jsr     DO_LITERAL
00:F07D  1000              :                 .word   16
Error: forth.asm (221) Undefined symbol: BASE
00:F07F  200000            :                 jsr     BASE
00:F082  4C8AF0            :                 jmp     STORE
                             
                             ;===============================================================================
                             ; Memory Operations
                             ;-------------------------------------------------------------------------------
                             
                             ; ! ( x a-addr -- )
                             ;
                             ; Store x at a-addr.
                             
                                             HEADER  1,"!",NORMAL
                           +                 LINK    NORMAL
00:F085  76F0              +                 .word   LASTWORD                ; Link
00:F087  00                +                 .byte   NORMAL                  ; Type
         0000F088          = LASTWORD        .set    $
00:F088  0121              +                 .byte   1,"!"
                             STORE:
00:F08A  B503              :                 lda     DSTACK+3,x      ; Fetch data value
00:F08C  8101              :                 sta     (DSTACK+1,x)    ; .. and store
00:F08E  F601              :                 inc     DSTACK+1,x
00:F090  D002              :                 if eq
00:F092  F602              :                  inc    DSTACK+2,x
                                             endif
00:F094  B504              :                 lda     DSTACK+4,x
00:F096  8101              :                 sta     (DSTACK+1,x)
00:F098  E8                :                 inx                     ; Clean up data stack
00:F099  E8                :                 inx
00:F09A  E8                :                 inx
00:F09B  E8                :                 inx
00:F09C  60                :                 rts                     ; Done
                             
                             ; +! ( n|u a-addr -- )
                             ;

Portable 65xx Assembler [16.06]

                             ; Add n|u to the single-cell number at a-addr.
                             
                                             HEADER  2,"+!",NORMAL
                           +                 LINK    NORMAL
00:F09D  88F0              +                 .word   LASTWORD                ; Link
00:F09F  00                +                 .byte   NORMAL                  ; Type
         0000F0A0          = LASTWORD        .set    $
00:F0A0  022B21            +                 .byte   2,"+!"
                             PLUS_STORE:
00:F0A3  18                :                 clc
00:F0A4  B503              :                 lda     DSTACK+3,x      ; Fetch data value
00:F0A6  6101              :                 adc     (DSTACK+1,x)
00:F0A8  8101              :                 sta     (DSTACK+1,x)
00:F0AA  F601              :                 inc     DSTACK+1,x
00:F0AC  D002              :                 if eq
00:F0AE  F602              :                  inc    DSTACK+2,x
                                             endif
00:F0B0  B504              :                 lda     DSTACK+4,x
00:F0B2  6101              :                 adc     (DSTACK+1,x)
00:F0B4  8101              :                 sta     (DSTACK+1,x)
00:F0B6  E8                :                 inx                     ; Clean up data stack
00:F0B7  E8                :                 inx
00:F0B8  E8                :                 inx
00:F0B9  E8                :                 inx
00:F0BA  60                :                 rts                     ; Done
                             
                             ; , ( x -- )
                             ;
                             ; Reserve one cell of data space and store x in the cell. If the data-space
                             ; pointer is aligned when , begins execution, it will remain aligned when ,
                             ; finishes execution. An ambiguous condition exists if the data-space pointer
                             ; is not aligned prior to execution of ,.
                             ;
                             ; In this implementation is its defined as:
                             ;
                             ;   HERE ! 1 CELLS ALLOT
                             
                                             LINK    NORMAL
00:F0BB  A0F0              +                 .word   LASTWORD                ; Link
00:F0BD  00                +                 .byte   NORMAL                  ; Type
         0000F0BE          = LASTWORD        .set    $
00:F0BE  012C              :                 .byte   1,","
                             COMMA:
00:F0C0  205CF1            :                 jsr     HERE
00:F0C3  208AF0            :                 jsr     STORE
Error: forth.asm (287) Undefined symbol: DO_LITERAL
00:F0C6  200000            :                 jsr     DO_LITERAL
00:F0C9  0100              :                 .word   1
00:F0CB  2095F1            :                 jsr     CELLS
00:F0CE  4C19F1            :                 jmp     ALLOT
                             
                             ; 2! ( x1 x2 a-addr -- )
                             ;
                             ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next

Portable 65xx Assembler [16.06]

                             ; consecutive cell.
                             ;
                             ; In this implementation is its defined as:
                             ;
                             ;   SWAP OVER ! CELL+ !.
                             
                                             HEADER  2,"2!",NORMAL
                           +                 LINK    NORMAL
00:F0D1  BEF0              +                 .word   LASTWORD                ; Link
00:F0D3  00                +                 .byte   NORMAL                  ; Type
         0000F0D4          = LASTWORD        .set    $
00:F0D4  023221            +                 .byte   2,"2!"
                             TWO_STORE:
00:F0D7  2068F2            :                 jsr     SWAP
00:F0DA  2055F2            :                 jsr     OVER
00:F0DD  208AF0            :                 jsr     STORE
00:F0E0  2081F1            :                 jsr     CELL_PLUS
00:F0E3  4C8AF0            :                 jmp     STORE
                             
                             ; 2@ ( a-addr -- x1 x2 )
                             ;
                             ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
                             ; the next consecutive cell.
                             ;
                             ; In this implementation is its defined as:
                             ;
                             ;   DUP CELL+ @ SWAP @
                             
                                             HEADER  2,"2@",NORMAL
                           +                 LINK    NORMAL
00:F0E6  D4F0              +                 .word   LASTWORD                ; Link
00:F0E8  00                +                 .byte   NORMAL                  ; Type
         0000F0E9          = LASTWORD        .set    $
00:F0E9  023240            +                 .byte   2,"2@"
                             TWO_FETCH:
00:F0EC  2030F2            :                 jsr     DUP
00:F0EF  2081F1            :                 jsr     CELL_PLUS
00:F0F2  2000F1            :                 jsr     FETCH
00:F0F5  2068F2            :                 jsr     SWAP
00:F0F8  4C00F1            :                 jmp     FETCH
                             
                             ; @ ( a-addr -- x )
                             ;
                             ; x is the value stored at a-addr.
                             
                                             HEADER  1,"@",NORMAL
                           +                 LINK    NORMAL
00:F0FB  E9F0              +                 .word   LASTWORD                ; Link
00:F0FD  00                +                 .byte   NORMAL                  ; Type
         0000F0FE          = LASTWORD        .set    $
00:F0FE  0140              +                 .byte   1,"@"
                             FETCH:
00:F100  A101              :                 lda     (DSTACK+1,x)    ; Fetch from memory
00:F102  A8                :                 tay

Portable 65xx Assembler [16.06]

00:F103  F601              :                 inc     DSTACK+1,x
00:F105  D002              :                 if eq
00:F107  F602              :                  inc    DSTACK+2,x
                                             endif
00:F109  A101              :                 lda     (DSTACK+1,x)
00:F10B  9502              :                 sta     DSTACK+2,x      ; .. and replace top value
00:F10D  9401              :                 sty     DSTACK+1,x                  
00:F10F  60                :                 rts                     ; Done
                             
                             ; ALLOT ( n -- )
                             ;
                             ; If n is greater than zero, reserve n address units of data space. If n is
                             ; less than zero, release |n| address units of data space. If n is zero, leave
                             ; the data-space pointer unchanged.
                             ;
                             ; In this implementation its is defined as:
                             ;
                             ;   DP +!
                             
                                             HEADER  5,"ALLOT",NORMAL
                           +                 LINK    NORMAL
00:F110  FEF0              +                 .word   LASTWORD                ; Link
00:F112  00                +                 .byte   NORMAL                  ; Type
         0000F113          = LASTWORD        .set    $
00:F113  05414C4C4F54      +                 .byte   5,"ALLOT"
                             ALLOT:
Error: forth.asm (355) Undefined symbol: DP
00:F119  200000            :                 jsr     DP
00:F11C  4CA3F0            :                 jmp     PLUS_STORE
                             
                             ; C! ( char c-addr -- )
                             ;
                             ; Store char at c-addr. When character size is smaller than cell size, only the
                             ; number of low-order bits corresponding to character size are transferred.
                             
                                             HEADER  2,"C!",NORMAL
                           +                 LINK    NORMAL
00:F11F  13F1              +                 .word   LASTWORD                ; Link
00:F121  00                +                 .byte   NORMAL                  ; Type
         0000F122          = LASTWORD        .set    $
00:F122  024321            +                 .byte   2,"C!"
                             C_STORE:
00:F125  B503              :                 lda     DSTACK+3,x      ; Fetch the data value
00:F127  8101              :                 sta     (DSTACK+1,x)    ; And store it
00:F129  E8                :                 inx                     ; Clean up the stack
00:F12A  E8                :                 inx
00:F12B  E8                :                 inx
00:F12C  E8                :                 inx
00:F12D  60                :                 rts                     ; Done
                             
                             ; C, ( char -- )
                             ;
                             ; Reserve space for one character in the data space and store char in the
                             ; space. If the data-space pointer is character aligned when C, begins

Portable 65xx Assembler [16.06]

                             ; execution, it will remain character aligned when C, finishes execution.
                             ; An ambiguous condition exists if the data-space pointer is not character-
                             ; aligned prior to execution of C,
                             ;
                             ;   HERE C! 1 CHARS ALLOT
                             
                                             LINK    NORMAL
00:F12E  22F1              +                 .word   LASTWORD                ; Link
00:F130  00                +                 .byte   NORMAL                  ; Type
         0000F131          = LASTWORD        .set    $
00:F131  02432C            :                 .byte   2,"C,"
                             C_COMMA:
00:F134  205CF1            :                 jsr     HERE
00:F137  2025F1            :                 jsr     C_STORE
Error: forth.asm (388) Undefined symbol: DO_LITERAL
00:F13A  200000            :                 jsr     DO_LITERAL
00:F13D  0100              :                 .word   1
00:F13F  20C5F1            :                 jsr     CHARS
00:F142  4C19F1            :                 jmp     ALLOT
                             
                             ; C@ ( c-addr -- char )
                             ;
                             ; Fetch the character stored at c-addr. When the cell size is greater than
                             ; character size, the unused high-order bits are all zeroes.
                             
                                             HEADER  2,"C@",NORMAL
                           +                 LINK    NORMAL
00:F145  31F1              +                 .word   LASTWORD                ; Link
00:F147  00                +                 .byte   NORMAL                  ; Type
         0000F148          = LASTWORD        .set    $
00:F148  024340            +                 .byte   2,"C@"
                             C_FETCH:
00:F14B  A101              :                 lda     (DSTACK+1,x)    ; Fetch the data byte
00:F14D  9501              :                 sta     DSTACK+1,x      ; .. and replace stack value
00:F14F  A900              :                 lda     #0
00:F151  9502              :                 sta     DSTACK+2,x
00:F153  60                :                 rts                     ; Done
                             
                             ; HERE ( -- addr )
                             ;
                             ; addr is the data-space pointer.
                             
                                             HEADER  4,"HERE",NORMAL
                           +                 LINK    NORMAL
00:F154  48F1              +                 .word   LASTWORD                ; Link
00:F156  00                +                 .byte   NORMAL                  ; Type
         0000F157          = LASTWORD        .set    $
00:F157  0448455245        +                 .byte   4,"HERE"
                             HERE:
Error: forth.asm (412) Undefined symbol: DP
00:F15C  200000            :                 jsr     DP
00:F15F  4C00F1            :                 jmp     FETCH
                             
                             ;===============================================================================

Portable 65xx Assembler [16.06]

                             ; Alignment
                             ;-------------------------------------------------------------------------------
                             
                             ; ALIGN ( -- )
                             ;
                             ; If the data-space pointer is not aligned, reserve enough space to align it.
                             
                                             HEADER  5,"ALIGN",NORMAL
                           +                 LINK    NORMAL
00:F162  57F1              +                 .word   LASTWORD                ; Link
00:F164  00                +                 .byte   NORMAL                  ; Type
         0000F165          = LASTWORD        .set    $
00:F165  05414C49474E      +                 .byte   5,"ALIGN"
                             ALIGN:
00:F16B  60                :                 rts                     ; Done
                             
                             ; ALIGNED ( addr -- a-addr )
                             ;
                             ; a-addr is the first aligned address greater than or equal to addr.
                             
                                             HEADER  7,"ALIGNED",NORMAL
                           +                 LINK    NORMAL
00:F16C  65F1              +                 .word   LASTWORD                ; Link
00:F16E  00                +                 .byte   NORMAL                  ; Type
         0000F16F          = LASTWORD        .set    $
00:F16F  07414C49474E4544  +                 .byte   7,"ALIGNED"
                             ALIGNED:
00:F177  60                :                 rts                     ; Done
                             
                             ; CELL+ ( a-addr1 -- a-addr2 )
                             ;
                             ; Add the size in address units of a cell to a-addr1, giving a-addr2.
                             
                                             HEADER  5,"CELL+",NORMAL
                           +                 LINK    NORMAL
00:F178  6FF1              +                 .word   LASTWORD                ; Link
00:F17A  00                +                 .byte   NORMAL                  ; Type
         0000F17B          = LASTWORD        .set    $
00:F17B  0543454C4C2B      +                 .byte   5,"CELL+"
                             CELL_PLUS:
                                                                     ; Bump the address by two
00:F181  A902              :                 lda     #2
00:F183  7501              :                 adc     DSTACK+1,x
00:F185  8501              :                 sta     DSTACK+1.x
00:F187  9002              :                 if cs
00:F189  F602              :                  inc    DSTACK+2,x
                                             endif
00:F18B  60                :                 rts                     ; Done
                             
                             ; CELLS ( n1 -- n2 )
                             ;
                             ; n2 is the size in address units of n1 cells.
                             
                                             HEADER  5,"CELLS",NORMAL

Portable 65xx Assembler [16.06]

                           +                 LINK    NORMAL
00:F18C  7BF1              +                 .word   LASTWORD                ; Link
00:F18E  00                +                 .byte   NORMAL                  ; Type
         0000F18F          = LASTWORD        .set    $
00:F18F  0543454C4C53      +                 .byte   5,"CELLS"
                             CELLS:
00:F195  1601              :                 asl     DSTACK+1,x      ; Two bytes per cell
00:F197  3602              :                 rol     DSTACK+2,x
00:F199  60                :                 rts                     ; Done
                             
                             ; CHAR+ ( c-addr1 -- c-addr2 )
                             ;
                             ; Add the size in address units of a character to c-addr1, giving c-addr2.
                             
                                             HEADER  5,"CHAR+",NORMAL
                           +                 LINK    NORMAL
00:F19A  8FF1              +                 .word   LASTWORD                ; Link
00:F19C  00                +                 .byte   NORMAL                  ; Type
         0000F19D          = LASTWORD        .set    $
00:F19D  05434841522B      +                 .byte   5,"CHAR+"
                             CHAR_PLUS:
00:F1A3  F601              :                 inc     DSTACK+1,x      ; Bump the address by one
00:F1A5  D002              :                 if eq
00:F1A7  F602              :                  inc    DSTACK+2,x
                                             endif
00:F1A9  60                :                 rts                     ; Done
                             
                             ; CHAR- ( c-addr1 -- c-addr2 )
                             ;
                             ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
                             
                                             HEADER  5,"CHAR-",NORMAL
                           +                 LINK    NORMAL
00:F1AA  9DF1              +                 .word   LASTWORD                ; Link
00:F1AC  00                +                 .byte   NORMAL                  ; Type
         0000F1AD          = LASTWORD        .set    $
00:F1AD  05434841522D      +                 .byte   5,"CHAR-"
                             CHAR_MINUS:
00:F1B3  A501              :                 lda     DSTACK+1.x
00:F1B5  D002              :                 if eq
00:F1B7  D602              :                  dec    DSTACK+2,x
                                             endif
00:F1B9  D601              :                 dec     DSTACK+1,x
00:F1BB  60                :                 rts                     ; Done
                             
                             ; CHARS ( n1 -- n2 )
                             ;
                             ; n2 is the size in address units of n1 characters.
                             
                                             HEADER  5,"CHARS",NORMAL
                           +                 LINK    NORMAL
00:F1BC  ADF1              +                 .word   LASTWORD                ; Link
00:F1BE  00                +                 .byte   NORMAL                  ; Type
         0000F1BF          = LASTWORD        .set    $

Portable 65xx Assembler [16.06]

00:F1BF  054348415253      +                 .byte   5,"CHARS"
                             CHARS:
00:F1C5  60                :                 rts                     ; Done
                                             
                             ;===============================================================================
                             ; Stack Operations
                             ;-------------------------------------------------------------------------------
                             
                             ; 2DROP ( x1 x2 -- )
                             ;
                             ; Drop cell pair x1 x2 from the stack.
                             
                                             HEADER  5,"2DROP",NORMAL
                           +                 LINK    NORMAL
00:F1C6  BFF1              +                 .word   LASTWORD                ; Link
00:F1C8  00                +                 .byte   NORMAL                  ; Type
         0000F1C9          = LASTWORD        .set    $
00:F1C9  053244524F50      +                 .byte   5,"2DROP"
                             TWO_DROP:
00:F1CF  E8                :                 inx                     ; Removed two words from stack
00:F1D0  E8                :                 inx
00:F1D1  E8                :                 inx
00:F1D2  E8                :                 inx
00:F1D3  60                :                 rts                     ; Done
                             
                             ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
                             ;
                             ; Duplicate cell pair x1 x2.
                             
                                             HEADER  4,"2DUP",NORMAL
                           +                 LINK    NORMAL
00:F1D4  C9F1              +                 .word   LASTWORD                ; Link
00:F1D6  00                +                 .byte   NORMAL                  ; Type
         0000F1D7          = LASTWORD        .set    $
00:F1D7  0432445550        +                 .byte   4,"2DUP"
                             TWO_DUP:
00:F1DC  CA                :                 dex                     ; Make space for new value
00:F1DD  CA                :                 dex
00:F1DE  CA                :                 dex
00:F1DF  CA                :                 dex
00:F1E0  B505              :                 lda     DSTACK+5,x      ; Copy top two values
00:F1E2  9501              :                 sta     DSTACK+1,x
00:F1E4  B506              :                 lda     DSTACK+6,x
00:F1E6  9502              :                 sta     DSTACK+2,x
00:F1E8  B507              :                 lda     DSTACK+7,x
00:F1EA  9503              :                 sta     DSTACK+3,x
00:F1EC  B508              :                 lda     DSTACK+8,x
00:F1EE  9504              :                 sta     DSTACK+4,x
00:F1F0  60                :                 rts                     ; Done
                             
                             ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
                             ;
                             ; Copy cell pair x1 x2 to the top of the stack.
                             

Portable 65xx Assembler [16.06]

                                             HEADER  5,"2OVER",NORMAL
                           +                 LINK    NORMAL
00:F1F1  D7F1              +                 .word   LASTWORD                ; Link
00:F1F3  00                +                 .byte   NORMAL                  ; Type
         0000F1F4          = LASTWORD        .set    $
00:F1F4  05324F564552      +                 .byte   5,"2OVER"
                             TWO_OVER:
00:F1FA  CA                :                 dex                     ; Make space for new value
00:F1FB  CA                :                 dex
00:F1FC  CA                :                 dex
00:F1FD  CA                :                 dex
00:F1FE  B509              :                 lda     DSTACK+9,x      ; Copy over two values
00:F200  9501              :                 sta     DSTACK+1,x
00:F202  B50A              :                 lda     DSTACK+10,x
00:F204  9502              :                 sta     DSTACK+2,x
00:F206  B50B              :                 lda     DSTACK+11,x
00:F208  9503              :                 sta     DSTACK+3,x
00:F20A  B50C              :                 lda     DSTACK+12,x
00:F20C  9504              :                 sta     DSTACK+4,x
00:F20E  60                :                 rts                     ; Done
                             
                             ; 2ROT ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
                             ;
                             ; Rotate the top three cell pairs on the stack bringing cell pair x1 x2 to
                             ; the top of the stack.
                             
                                     .if     0
                                             HEADER  4,"2ROT",NORMAL
                           +                 LINK    NORMAL
                           -                 .word   LASTWORD                ; Link
                           -                 .byte   NORMAL                  ; Type
                           - LASTWORD        .set    $
                           -                 .byte   4,"2ROT"
                           - TWO_ROT:        jsr     DO_COLON
                           -                 lda     <11                     ; Save x1
                           -                 pha
                           -                 lda     <9                      ; Save x2
                           -                 pha
                           -                 lda     <7                      ; Move x3
                           -                 sta     <11
                           -                 lda     <5                      ; Move x4
                           -                 sta     <9
                           -                 lda     <3                      ; Move x5
                           -                 sta     <7
                           -                 lda     <1                      ; Move x6
                           -                 sta     <5
                           -                 pla                             ; Restore x2
                           -                 sta     <1
                           -                 pla                             ; Restore x1
                           -                 sta     <3
                           -                 CONTINUE                        ; Done
                                     .endif
                                     
                             ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )

Portable 65xx Assembler [16.06]

                             ;
                             ; Exchange the top two cell pairs.
                             
                                     .if     0
                                             HEADER  5,"2SWAP",NORMAL
                           +                 LINK    NORMAL
                           -                 .word   LASTWORD                ; Link
                           -                 .byte   NORMAL                  ; Type
                           - LASTWORD        .set    $
                           -                 .byte   5,"2SWAP"
                           - TWO_SWAP:
                           -                 lda     <3                      ; Save x3
                           -                 pha
                           -                 lda     <1                      ; Save x4
                           -                 pha
                           -                 lda     <7                      ; Move x1
                           -                 sta     <3
                           -                 lda     <5                      ; Move x2
                           -                 sta     <1
                           -                 pla                             ; Move x4
                           -                 sta     <5
                           -                 pla                             ; Move x3
                           -                 sta     <7
                           -                 CONTINUE                        ; Done
                                     .endif
                                     
                             ; ?DUP ( x -- 0 | x x )
                             ;
                             ; Duplicate x if it is non-zero.
                             
                                             HEADER  4,"?DUP",NORMAL
                           +                 LINK    NORMAL
00:F20F  F4F1              +                 .word   LASTWORD                ; Link
00:F211  00                +                 .byte   NORMAL                  ; Type
         0000F212          = LASTWORD        .set    $
00:F212  043F445550        +                 .byte   4,"?DUP"
                             QUERY_DUP:
00:F217  B501              :                 lda     DSTACK+1,x      ; Fetch top value
00:F219  1502              :                 ora     DSTACK+2,x
00:F21B  D013              :                 bne     DUP             ; Non-zero value?
00:F21D  60                :                 rts                     ; Done
                             
                             ; DEPTH ( -- +n )
                             ;
                             ; +n is the number of single-cell values contained in the data stack before +n
                             ; was placed on the stack.
                             
                                     .if 0
                                             HEADER  5,"DEPTH",NORMAL
                           +                 LINK    NORMAL
                           -                 .word   LASTWORD                ; Link
                           -                 .byte   NORMAL                  ; Type
                           - LASTWORD        .set    $
                           -                 .byte   5,"DEPTH"

Portable 65xx Assembler [16.06]

                           - DEPTH:          jsr     DO_COLON
                                             dw      AT_DP
                                             dw      DO_LITERAL,DSTACK_END-1
                                             dw      SWAP
                                             dw      MINUS
                                             dw      TWO_SLASH
                                             dw      EXIT
                                     .endif
                             
                             ; DROP ( x -- )
                             ;
                             ; Remove x from the stack.
                             
                                             HEADER  4,"DROP",NORMAL|INLINE
                           +                 LINK    NORMAL|INLINE
00:F21E  12F2              +                 .word   LASTWORD                ; Link
00:F220  40                +                 .byte   NORMAL|INLINE                   ; Type
         0000F221          = LASTWORD        .set    $
00:F221  0444524F50        +                 .byte   4,"DROP"
                             DROP:
00:F226  E8                :                 inx                     ; Drop the top value
00:F227  E8                :                 inx
00:F228  60                :                 rts                     ; Done
                             
                             ; DUP ( x -- x x )
                             ;
                             ; Duplicate x.
                             
                                             HEADER  3,"DUP",NORMAL
                           +                 LINK    NORMAL
00:F229  21F2              +                 .word   LASTWORD                ; Link
00:F22B  00                +                 .byte   NORMAL                  ; Type
         0000F22C          = LASTWORD        .set    $
00:F22C  03445550          +                 .byte   3,"DUP"
                             DUP:
00:F230  CA                :                 dex
00:F231  CA                :                 dex
00:F232  B503              :                 lda     DSTACK+3,x      ; Copy the top value
00:F234  9501              :                 sta     DSTACK+1,x
00:F236  B504              :                 lda     DSTACK+4,x
00:F238  9502              :                 sta     DSTACK+2,x
00:F23A  60                :                 rts                     ; Done
                             
                             ; NIP ( x1 x2 -- x2 )
                             ;
                             ; Drop the first item below the top of stack.
                             
                                             HEADER  3,"NIP",NORMAL
                           +                 LINK    NORMAL
00:F23B  2CF2              +                 .word   LASTWORD                ; Link
00:F23D  00                +                 .byte   NORMAL                  ; Type
         0000F23E          = LASTWORD        .set    $
00:F23E  034E4950          +                 .byte   3,"NIP"
                             NIP:

Portable 65xx Assembler [16.06]

00:F242  B501              :                 lda     DSTACK+1,x      ; Copy x2 over x1
00:F244  9503              :                 sta     DSTACK+3,x
00:F246  B502              :                 lda     DSTACK+2,x
00:F248  9504              :                 sta     DSTACK+4,x
00:F24A  4C26F2            :                 jmp     DROP
                             
                             ; OVER ( x1 x2 -- x1 x2 x1 )
                             ;
                             ; Place a copy of x1 on top of the stack.
                             
                                             HEADER  4,"OVER",NORMAL
                           +                 LINK    NORMAL
00:F24D  3EF2              +                 .word   LASTWORD                ; Link
00:F24F  00                +                 .byte   NORMAL                  ; Type
         0000F250          = LASTWORD        .set    $
00:F250  044F564552        +                 .byte   4,"OVER"
                             OVER:
00:F255  CA                :                 dex
00:F256  CA                :                 dex
00:F257  B503              :                 lda     DSTACK+3,x      ; Fetch second value
00:F259  9501              :                 sta     DSTACK+1,x      ; And make a copy
00:F25B  B504              :                 lda     DSTACK+4,x
00:F25D  9502              :                 sta     DSTACK+2,x
00:F25F  60                :                 rts                     ; Done
                             
                             ; PICK ( xu ... x1 x0 u -- xu ... x1 x0 xu )
                             ;
                             ; Remove u. Copy the xu to the top of the stack. An ambiguous condition exists
                             ; if there are less than u+2 items on the stack before PICK is executed.
                             
                                     .if     0
                                             HEADER  4,"PICK",NORMAL
                           +                 LINK    NORMAL
                           -                 .word   LASTWORD                ; Link
                           -                 .byte   NORMAL                  ; Type
                           - LASTWORD        .set    $
                           -                 .byte   4,"PICK"
                           - PICK:
                           -                 lda     <1                      ; Fetch the index
                           -                 asl     a
                           -                 tax
                           -                 lda     <3,x                    ; Load the target value
                           -                 sta     <1                      ; .. and save
                           -                 CONTINUE                        ; Done
                                     .endif
                                     
                             ; ROLL ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
                             ;
                             ; Remove u. Rotate u+1 items on the top of the stack. An ambiguous condition
                             ; exists if there are less than u+2 items on the stack before ROLL is executed.
                             
                                     .if 0
                                             HEADER  4,"ROLL",NORMAL
                           +                 LINK    NORMAL

Portable 65xx Assembler [16.06]

                